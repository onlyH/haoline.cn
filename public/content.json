{"meta":{"title":"郝洁的小栈","subtitle":"shaun web","description":"web开发","author":"郝洁","url":"http://onlyH.github.io"},"pages":[{"title":"categories","date":"2018-09-29T02:43:32.000Z","updated":"2021-06-30T02:45:56.993Z","comments":false,"path":"categories/index.html","permalink":"http://onlyH.github.io/categories/index.html","excerpt":"","text":"参数 描述 默认值layout 布局title 标题date 建立日期 文件建立日期updated 更新日期 文件更新日期comments 开启文章的评论功能 truetags 标签（不适用于分页）categories 分类（不适用于分页）permalink 覆盖文章网址"},{"title":"","date":"2021-03-15T08:13:37.553Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"about/index.html","permalink":"http://onlyH.github.io/about/index.html","excerpt":"","text":"联系方式个人信息 郝洁/女 本科/黄河科技大学/2018 工作年限：2年 技术博客：haoline.cn Github：http://github.com/onlyH 期望职位：web前端 期望城市：北京 工作经历新加坡艾克伦公司北京代表处 （ 2018年2月 ~ 至今 ）后台管理项目，超级管理后台项目 （2018.03-2018.05）项目描述：该管理平台是针对上课系统进行功能补充的后台管理平台。可进行对教室、教师、学生等信息数据的收集管理。角色分为管理员、教师、助教、学生和巡课。超级管理后台中进行的是对Tuition Cloud管理后台的管理。具有企业管理和订单管理两个功能模块，用于为使用企业注册帐号，添加订单。 项目职责： 独立开发，使用vue，对各个角色分配权限，支持国际化语言切换。 采用element-ui对页面进行布局，交互。 采用localstorage存储客户数据，与后台对接接口。 采用$route.params传递用户标识token。 采用vuex，EventBus做数据状态管理。 项目重构，用了 axios 技术方案，自动转换JSON数据，拦截请求和响应转换请求和响应数据，研发成本大大降低。 学生端，机构端项目（2018.05-2018.10）项目描述：学生端：包含人信息相关操作，选课，上课，购买课程流程，线上购课流程。机构端：包含教学管理，监课管理，机构管理，交易管理等模块。邮件提醒功能等。 项目职责： 采用bootstrap独立开发机构端和学生端的所有页面，部分交互逻辑。 使用momentjs对时间格式化做统一处理。 采用i18n对语言做国际化处理。 使用vue对页面模块拆块，复用组件。 使用fullCalendar.js管理日程安排、工作计划。 使用pagination.js实现页面分页功能。 其他 制定公司前端代码规范，并上传GitHub，并实施执行监督。 熟练使用Git，每日上传代码到GitHub进行托管。 每次开发前，参加项目prd评审，提出参考方案。 评审结束后，参与UI设计探讨方针，探讨UI细节，提出方案。 项目实践Vue—电商平台系统开发语言： html5/css3/es6/vue/vue-resource/vuex/vue-router; GitHub： https://github.com/onlyH/The-electricity-system-vue- vue-resource 功能实现： 实现Ajax获取信息数据、幻灯片组件、登录、添加路由，select选项组件，可多选项组件，数字组件，总价计算，选择银行，订单列表，vuex状态管理应用。 Vue—购物项目开发语言： html5/css3/javascript/vue/vue-resource; GitHub： https://github.com/onlyH/vue-shopping 功能实现： 通过v-for指令渲染产品数据，使用filter对金额进行格式化，为金额前加上金额货币符号。v-on绑定点击事件实现产品金额的动态计算，v-model实时变化。 GitHub onlyH 博客-郝洁的博客 技能清单 Web开发：javascript/less/jQuery/css3/html5/es6/vue 前端框架：element-ui/mui/bootstrap/highcharts/movejs/ animate.css 前端工具：koala/firebug/chrome/webstrom/HBuilder/gulp/webpack/vscode 版本管理、文档和自动化部署工具：Svn/Git 在校奖励 2015年6月 荣获自动化专业三等奖学金 2017年2月 荣获自动化专业三等奖学金 2018年6月 荣获自动化专业二等奖学金自我评价对前端有着极大的兴趣和热情，具备自主学习能力，喜欢专研思考问题，做事耐心执着，追求完美。"},{"title":"tags","date":"2018-09-29T02:58:53.000Z","updated":"2019-07-28T07:56:28.000Z","comments":false,"path":"tags/index.html","permalink":"http://onlyH.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"github访问代理映射","slug":"github访问代理映射","date":"2021-07-01T02:39:40.000Z","updated":"2021-07-01T02:46:56.053Z","comments":true,"path":"2021/07/01/github访问代理映射/","link":"","permalink":"http://onlyH.github.io/2021/07/01/github访问代理映射/","excerpt":"为本地 hosts 文件添加 Github 相关映射 打开本地 hosts 文件 win + r =&gt; C:\\WINDOWS\\system32\\drivers\\etc进入 获取 Github 相关网站的 IP 访问 https://www.ipaddress.com 输入 github.global.ssl.fastly.net 和 github.com，查询ip地址","text":"为本地 hosts 文件添加 Github 相关映射 打开本地 hosts 文件 win + r =&gt; C:\\WINDOWS\\system32\\drivers\\etc进入 获取 Github 相关网站的 IP 访问 https://www.ipaddress.com 输入 github.global.ssl.fastly.net 和 github.com，查询ip地址 将查询到的内容填写到hosts文件中： 12140.82.112.3 github.com199.232.69.194 github.global.ssl.fastly.net 使用ping github.com查询是否配置成功","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"技巧","slug":"技巧","permalink":"http://onlyH.github.io/tags/技巧/"}]},{"title":"vue3-新特性","slug":"vue3-新特性","date":"2021-06-18T06:27:55.000Z","updated":"2021-06-30T08:09:09.474Z","comments":true,"path":"2021/06/18/vue3-新特性/","link":"","permalink":"http://onlyH.github.io/2021/06/18/vue3-新特性/","excerpt":"性能提升 打包大小减少41% 初次渲染快55%，133% 内存使用减少54% Composition API","text":"性能提升 打包大小减少41% 初次渲染快55%，133% 内存使用减少54% Composition API ref和reactive computed和watch 新的生命周期函数 自定义函数-Hooks函数 新增特性 Teleport 瞬移组件的位置 Suspense 异步加载组件的新福音 全局API的修改和优化 更多的试验性特性 更好的ts支持为什么要有vue3（解决现有存在的棘手问题） 随着功能的增长，复杂组件的代码变得难以维护 Mixin的缺点 明明冲突 不清楚暴露出来的变量的作用 重用到其他component经常遇到问题 setup中无法访问this 新生命周期","categories":[{"name":"技术","slug":"技术","permalink":"http://onlyH.github.io/categories/技术/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"感悟","slug":"感悟","permalink":"http://onlyH.github.io/tags/感悟/"}]},{"title":"vue3-ts","slug":"vue3-ts","date":"2021-06-17T08:24:18.000Z","updated":"2021-06-17T08:36:32.365Z","comments":true,"path":"2021/06/17/vue3-ts/","link":"","permalink":"http://onlyH.github.io/2021/06/17/vue3-ts/","excerpt":"程序 更容易理解 函数或者方法输入输出的参数类型，外部条件等 动态语言的约束：需要手动调整等过程 有了ts，diamante本身就可以回答上述问题 效率更高","text":"程序 更容易理解 函数或者方法输入输出的参数类型，外部条件等 动态语言的约束：需要手动调整等过程 有了ts，diamante本身就可以回答上述问题 效率更高 在不同的代码块和定义中进行跳转 代码自动补全 丰富的接口提示 更少的错误 编译期间能够发现大部分错误 杜绝一些比较常见错误 非常好的包容性 完全兼容js 第三方库可以单独编写类型文件 不足 增加学习成本 短期内增加开发成本","categories":[],"tags":[]},{"title":"开发小技巧","slug":"17","date":"2021-06-17T07:33:03.000Z","updated":"2021-06-17T07:40:55.929Z","comments":true,"path":"2021/06/17/17/","link":"","permalink":"http://onlyH.github.io/2021/06/17/17/","excerpt":"分页删除最后一条返回上一页12const totalPage =Math.ceil((this.page.total -1)/res.pageSize);this.page.currentPage = this.page.currentPage &lt;1 ?1 :this.page.currentPage &gt; totalPage ?totalPage :this.page.currentPage Git报错处理","text":"分页删除最后一条返回上一页12const totalPage =Math.ceil((this.page.total -1)/res.pageSize);this.page.currentPage = this.page.currentPage &lt;1 ?1 :this.page.currentPage &gt; totalPage ?totalPage :this.page.currentPage Git报错处理OpenSSL SSL_read: Connection was reset, errno 10054 这是服务器的SSL证书没有经过第三方机构的签署，所以报错。 解决办法： git config --global http.sslVerify &quot;false&quot; github链接","categories":[],"tags":[]},{"title":"ES6系列-类与对象","slug":"类与对象","date":"2021-03-15T08:13:37.578Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/类与对象/","link":"","permalink":"http://onlyH.github.io/2021/03/15/类与对象/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 类与对象&#123; class Person &#123; constructor(name = 'yoyo') &#123; this.name = name; &#125; &#125; let v_person = new Person('v') console.log(v_person) //Person &#123;name: \"v\"&#125; class Child extends Person &#123; constructor(name = 'child') &#123; // super()会使用父类的所有 super(name) this.type = 'dog' &#125; &#125; console.log(new Child()) //Child &#123;name: \"child\", type: \"dog\"&#125; console.log(new Child('hello')) //Child &#123;name: \"hello\", type: \"dog\"&#125;&#125;// getter,setter&#123; class Person &#123; constructor(name = 'yoy') &#123; this.name = name &#125; get longName() &#123; return this.name + '读取属性' &#125; set longName(value) &#123; this.name = value &#125; &#125; let v = new Person() console.log(v.longName, 'getter')//yoy读取属性 getter v.longName = 'hello' console.log(v.longName) //hello读取属性 let vs = new Person('lele') console.log(vs.longName, 'setter') //lele读取属性 setter&#125;&#123; // 静态方法，不是使用类的实例去调用 class Person &#123; constructor(name = 'yoyo') &#123; this.name = name &#125; static tail() &#123; console.log('this is tail') &#125; &#125; Person.tail()&#125;&#123; // 静态属性 ===&gt; 直接在类上定义 class Person &#123; constructor(name = 'uouo') &#123; this.name = name &#125; static tail() &#123; console.log('this is tail') &#125; &#125; Person.numberId = 23333 console.log(Person.numberId) //2333&#125;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"截取字符串最方便的办法","slug":"截取字符串","date":"2021-03-15T08:13:37.577Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/截取字符串/","link":"","permalink":"http://onlyH.github.io/2021/03/15/截取字符串/","excerpt":"","text":"今日解析YouTube视频，采用了YouTube的iframe。其中有一坑是YouTube不允许输入第三方链接，也就是不解析，解决的办法就是http://www.youtube.com/embed/VIDEO_ID 例如：https://www.youtube.com/watch?v=78tNYZUS-ps改为：http://www.youtube.com/embed/78tNYZUS-ps 为了判断输入的URL是否是一个有效的，我们采取了后台解析id的办法，返回title。那么我就需要将用户输入的链接进行截取。试了好几种办法，虽然都能实现，但是觉得麻烦，最终选择了，split()方法，他可以将一个字符串分割成字符串数组。 1234let url = 'https://www.youtube.com/watch?v=78tNYZUS-ps';let front = url.split('=')[0]let end = url.split('=')[1]console.log(front,end) //https://www.youtube.com/watch?v 78tNYZUS-ps","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"富文本-select改进","slug":"改进-select","date":"2021-03-15T08:13:37.577Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/改进-select/","link":"","permalink":"http://onlyH.github.io/2021/03/15/改进-select/","excerpt":"之前在项目中，做了一个富文本编辑器，第一次用的是原生js实现，第二次用vue实现功能，在select里面定义可以选择字体的大小，当时采取的是@input去实现，无聊时读了下vue文档，发现其实。。是可以改进的，比如说v-model是一个语法糖，文档是这样说的： 自定义事件也可以用于创建支持 v-model 的自定义输入组件input v-nodel=searchText等价于：1&lt;input v-bind:value='searchText' v-on:input='$event.target.value'&gt; 而我当时的实现就有一些复杂123456789101112131415161718 &lt;select name=\"fontSize\" class=\"fontSize\" @change=\"showSize($event)\"&gt; &lt;option :value=\"ops.value\" v-for=\"ops in fontSize\" :selected=\"ops.value == 16 ? true: '' \"&gt;&#123;&#123;ops.value&#125;&#125;&lt;/option&gt; &lt;/select&gt;showSize: function (ev) &#123; var execFontSize = function (size, unit) &#123; var spanString = $('&lt;span/&gt;', &#123; 'text': document.getSelection() &#125;).css( &#123;'font-size': size + unit, 'color': `#$&#123;this.designColor&#125;`&#125;).prop('outerHTML'); document.execCommand('insertHTML', false, spanString); &#125;; const value = ev.target.value; execFontSize(value, 'px')&#125;","text":"之前在项目中，做了一个富文本编辑器，第一次用的是原生js实现，第二次用vue实现功能，在select里面定义可以选择字体的大小，当时采取的是@input去实现，无聊时读了下vue文档，发现其实。。是可以改进的，比如说v-model是一个语法糖，文档是这样说的： 自定义事件也可以用于创建支持 v-model 的自定义输入组件input v-nodel=searchText等价于：1&lt;input v-bind:value='searchText' v-on:input='$event.target.value'&gt; 而我当时的实现就有一些复杂123456789101112131415161718 &lt;select name=\"fontSize\" class=\"fontSize\" @change=\"showSize($event)\"&gt; &lt;option :value=\"ops.value\" v-for=\"ops in fontSize\" :selected=\"ops.value == 16 ? true: '' \"&gt;&#123;&#123;ops.value&#125;&#125;&lt;/option&gt; &lt;/select&gt;showSize: function (ev) &#123; var execFontSize = function (size, unit) &#123; var spanString = $('&lt;span/&gt;', &#123; 'text': document.getSelection() &#125;).css( &#123;'font-size': size + unit, 'color': `#$&#123;this.designColor&#125;`&#125;).prop('outerHTML'); document.execCommand('insertHTML', false, spanString); &#125;; const value = ev.target.value; execFontSize(value, 'px')&#125; 嗯嗯，改起来~~","categories":[{"name":"vue","slug":"vue","permalink":"http://onlyH.github.io/categories/vue/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"功能","slug":"功能","permalink":"http://onlyH.github.io/tags/功能/"}]},{"title":"封装--逐步运动","slug":"封装运动1","date":"2021-03-15T08:13:37.576Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/封装运动1/","link":"","permalink":"http://onlyH.github.io/2021/03/15/封装运动1/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344//html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; div &#123; width: 200px; height: 200px; opacity: .3; background-color: yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script src=\"moveOne.js\"&gt;&lt;/script&gt; &lt;script&gt; var tag = $tag('div') tag.onmouseover = function() &#123; starSport(tag, 'width', 400, function() &#123; starSport(tag, 'opacity', 100) &#125;) &#125; tag.onmouseout = function() &#123; starSport(tag, 'width', 200, function() &#123; starSport(tag, 'opacity', 30) &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//moveOne.jsfunction $tag(id) &#123; return document.querySelector(id)&#125;//获取样式属性function getStyle(obj, attr) &#123; if (obj.currentStyle) &#123; return obj.currentStyle[attr] &#125; else &#123; return getComputedStyle(obj, false)[attr] &#125;&#125;//运动function starSport(obj, attr, target, fn) &#123; //当前对象，属性，变化对象 obj.timer = null clearInterval(obj.timer) obj.timer = setInterval(function () &#123; var current = 0 //定义当前属性 if (attr === 'opacity') &#123; current = Math.round(parseFloat(getStyle(obj, attr) * 100)) &#125; else &#123; current = parseInt(getStyle(obj, attr)) &#125; //定义速度 var speed = (target - current) / 8 speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed) //如果当前值等于目标值 if (current === target) &#123; //如果第一次运动停止 clearInterval(obj.timer) if (fn) &#123; fn() &#125; &#125; else &#123; if (attr === 'opacity') &#123; obj.style[attr] = (current + speed) / 100 &#125; else &#123; obj.style[attr] = current + speed + 'px' &#125; &#125; &#125;, 30)&#125;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"封装","slug":"封装","permalink":"http://onlyH.github.io/tags/封装/"}]},{"title":"异步回调处理","slug":"异步回调","date":"2021-03-15T08:13:37.576Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/异步回调/","link":"","permalink":"http://onlyH.github.io/2021/03/15/异步回调/","excerpt":"之前异步回调总是出现问题，先上一段错误的代码123456callbacking = falseif(!this.callbacking) &#123; this.callbacking = true this.callback() this.callbacking = false&#125; 这段代码会走this.callbacking = false但是没有意义，如果callback是同步的，这个if在callback执行期间不再会走第二次，如果是异步的，这样写是不对的。我的callback是异步的。。所以这样写的效果是这样的123this.callbacking = truethis.callback() //发起异步请求后callback函数结束（请求未完成）this.callbacking = false 也就是说，callbacking在异步请求没有结束的时候就已经回归到false了，无法起到想要的作用。应该这样写：1234this.callbacking = truethis.callback(()=&gt;&#123; this.callbacking = false&#125;)","text":"之前异步回调总是出现问题，先上一段错误的代码123456callbacking = falseif(!this.callbacking) &#123; this.callbacking = true this.callback() this.callbacking = false&#125; 这段代码会走this.callbacking = false但是没有意义，如果callback是同步的，这个if在callback执行期间不再会走第二次，如果是异步的，这样写是不对的。我的callback是异步的。。所以这样写的效果是这样的123this.callbacking = truethis.callback() //发起异步请求后callback函数结束（请求未完成）this.callbacking = false 也就是说，callbacking在异步请求没有结束的时候就已经回归到false了，无法起到想要的作用。应该这样写：1234this.callbacking = truethis.callback(()=&gt;&#123; this.callbacking = false&#125;) callback接受的函数需要在异步完成后执行。这样才能保证指定代码在异步操作完成后才执行，比如说在this.callbacking = true上锁后，是希望在异步操作结束后才解锁。 或者使用promise，在.then().then解决","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"动态添加属性（set）","slug":"动态添加属性","date":"2021-03-15T08:13:37.574Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/动态添加属性/","link":"","permalink":"http://onlyH.github.io/2021/03/15/动态添加属性/","excerpt":"","text":"使用vue动态的添加属性，假设从父组件props传来一个数组，要为数组中的每一项添加一个属性，每个属性点击一次就+1，大于2的时候就为0，（0，1，2），添加另一组属性，当为0的时候显示一张图，当为1的时候，显示另一张图片，当为1的时候再换一张图片。当点击某一个按钮，剩余其他的状态要归0，图片显示0的对应的图片。代码实现如下：123456789101112131415161718192021222324252627282930313233itemsTrans:&#123;&#125;,currentSort: 0,//当前排序created() &#123; this.content.titles.forEach((i,index)=&gt;&#123; this.$set(this.itemsTrans,`toggle$&#123;index&#125;`,0) this.$set(this.itemsTrans,`toggle$&#123;index&#125;img`,'xxx.png') &#125;)&#125;methods:&#123; changeToggle(item,index) &#123; for(let i = 0; i &lt; this.content.titles.length;i++) &#123; //返回默认状态 if(i !== index) &#123; this.itemsTrans[`toggle$&#123;i&#125;`] = 0 this.itemsTrans[`toggle$&#123;i&#125;img`] = 'xxx.png' &#125; &#125; this.itemsTrans[`toggle$&#123;index&#125;`] += 1 if (this.itemTrans[`toggle$&#123;index&#125;`] == 1) &#123; this.content.currentSort = 1 this.itemTrans[`toggle$&#123;index&#125;img`] = 'yyy.png' &#125; if (this.itemTrans[`toggle$&#123;index&#125;`] == 2) &#123; this.content.currentSort = 2 this.itemTrans[`toggle$&#123;index&#125;img`] = 'zzz.png' &#125; if (this.itemTrans[`toggle$&#123;index&#125;`] &gt; 2) &#123; this.itemTrans[`toggle$&#123;index&#125;img`] = 0 this.itemTrans[`toggle$&#123;index&#125;`] = 'xxx.png' this.content.currentSort = 0 &#125; &#125;&#125; 如果要做数据加载分页的话一定要先切割，以免出现数据重复。12this.content.items.splice(0,this.content.items.length)this.content.items.push(...items)","categories":[{"name":"vue","slug":"vue","permalink":"http://onlyH.github.io/categories/vue/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"webpack端口号","slug":"webpack端口","date":"2021-03-15T08:13:37.572Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/webpack端口/","link":"","permalink":"http://onlyH.github.io/2021/03/15/webpack端口/","excerpt":"","text":"今日，修改webpack端口号，遇到了问题本来是在webpack.config.js文件夹里添加了devServer属性123456789101112131415 devServer: &#123; port: 2333, host: '0.0.0.0', overlay: &#123; errors: true &#125;, hot: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin(),]``` `webpack-dev-server` 带 `hot` 参数的时候，要去掉config里面的 HotModuleReplacementPlugin不然会内存溢出。解决办法：删除 plugins: [ new webpack.HotModuleReplacementPlugin()]`将&quot;dev&quot;: &quot;webpack-dev-server --mode development&quot;,改为&quot;dev&quot;: &quot;webpack-dev-server --hot --inline&quot;,启动服务并不能自动刷新，要自动刷新需要用到webpack-dev-server –hot –inline当使用webpack-dev-server –hot –inline命令时，在每次修改文件，是将文件打包 保存在内存中并没有写在磁盘里(默认是根据webpack.config.js打包文件，通过–config xxxx.js修改)，这种打包得到的文件 和项目根目录中的index.html位于同一级（你看不到，因为 它在内存中并没有在磁盘里）。使用webpack命令将打包后的文件保存在磁盘中 例如在index.html文件中引入通过webpack-dev-server –hot –inline打包的build.js&lt;script src=&quot;build.js&quot;&gt;&lt;/script&gt; 在index.html文件中引入通过webpack命令打包的build.js&lt;script src=&quot;./build/build.js&quot;&gt;&lt;/script&gt;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"webpack配置","slug":"webpack","date":"2021-03-15T08:13:37.571Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/webpack/","link":"","permalink":"http://onlyH.github.io/2021/03/15/webpack/","excerpt":"webpack属性配置12345678910111213141516171819202122232425262728293031323334353637383940const path = require('path')module.exports = &#123; entry:&#123; //main默认入口，可以是多入口 main:'./src/main.js' &#125;, //出口 output:&#123; filemane:'./build.js', //指定js文件 path:path.join(__dirname,'..','dist',) //最好是绝对路径，代表当前目录的上一级的dist &#125;, module:&#123; // 一样的功能rules: webpack2.x之后新加的 loaders:[ require('./a.css||./a.js') &#123;test:/\\.css$/, loader:'style-loader!css-loader', // 顺序是反过来的2!1 &#125;, &#123; test:/\\.(jpg|svg)$/, loader:'url-loader?limit=4096&amp;name=[name].[ext]', // 顺序是反过来的2!1 // [name].[ext]内置提供的，因为本身是先读这个文件 options:&#123; limit:4096, name:'[name].[ext]' &#125; &#125; ] &#125;, plugins:[ // 插件的执行顺序是依次执行的 new htmlWebpackPlugin(&#123; template:'./src/index.html', &#125;) //将src下的template属性描述的文件根据当前配置的output.path，将文件移动到该目录 ]&#125; webpack-es6","text":"webpack属性配置12345678910111213141516171819202122232425262728293031323334353637383940const path = require('path')module.exports = &#123; entry:&#123; //main默认入口，可以是多入口 main:'./src/main.js' &#125;, //出口 output:&#123; filemane:'./build.js', //指定js文件 path:path.join(__dirname,'..','dist',) //最好是绝对路径，代表当前目录的上一级的dist &#125;, module:&#123; // 一样的功能rules: webpack2.x之后新加的 loaders:[ require('./a.css||./a.js') &#123;test:/\\.css$/, loader:'style-loader!css-loader', // 顺序是反过来的2!1 &#125;, &#123; test:/\\.(jpg|svg)$/, loader:'url-loader?limit=4096&amp;name=[name].[ext]', // 顺序是反过来的2!1 // [name].[ext]内置提供的，因为本身是先读这个文件 options:&#123; limit:4096, name:'[name].[ext]' &#125; &#125; ] &#125;, plugins:[ // 插件的执行顺序是依次执行的 new htmlWebpackPlugin(&#123; template:'./src/index.html', &#125;) //将src下的template属性描述的文件根据当前配置的output.path，将文件移动到该目录 ]&#125; webpack-es6 vue默认支持es6的模块导入导出 babel–&gt;babel-core es6模块123456789//defaultimport [,...xxx] [,..form] './xxx.ext'export default obj;//声明式export var obj = xxxexport var obj2 = &#123;&#125;export &#123;stu&#125;//单独导出import &#123;obj,obj2,stu&#125; form './xxx.js' //直接使用obj 默认导出和声明式导入在使用上的区别 声明式导入的时候，必须{名称} 名称要一致（按需导入) 默认导入，可以随意的使用变量名 123456789&#123;default:\"我是默认导出的结果\" import xxx from './cal.js'会获取到整个对象的default属性obj1:\"我是声明式导出1\"obj2:\"我是声明式导出2\" obj3:\"我是声明式导出3\" import &#123;obj1,obj2&#125;obj4:\"我是声明式导出4\"&#125; import * as allObj from './cal.js'; 获取的就是一整个对象 import 和export一定写在顶级，不要包含在{}内 build：打包配置所在的文件夹 打包的配置 开发项目的源码 App.vue入口组件(.vue都是一个组件) main.js项目入口的文件 static：静态资源 webpack.base.conf.js 打包核心的配置与config-&gt;index.js可以合并成为一个 build.js打生产包 package.json 项目描述 dependencies：依赖库 devDependencied：开发依赖库 engines： 引擎 browserslist：浏览器列表","categories":[{"name":"webpack","slug":"webpack","permalink":"http://onlyH.github.io/categories/webpack/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"感悟","slug":"感悟","permalink":"http://onlyH.github.io/tags/感悟/"}]},{"title":"webpack.config.js配置错误问题","slug":"webpack-babel-core","date":"2021-03-15T08:13:37.571Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/webpack-babel-core/","link":"","permalink":"http://onlyH.github.io/2021/03/15/webpack-babel-core/","excerpt":"今日搭建webpack的时候，一直在报错，其中一个问题是Cannot find module &#39;@babel/core&#39;问题最初以为是babel-core没有安装上。重装了好几遍babel-core还是不行。对照以前的项目,发现babel-loader的版本不一样,之前的是@7.1.5版本,而现在是@8.0.0版本。 解决办法：降版本。。。npm uninstall babel-loader npm install babel-loader@7.1.5 官方文档说：","text":"今日搭建webpack的时候，一直在报错，其中一个问题是Cannot find module &#39;@babel/core&#39;问题最初以为是babel-core没有安装上。重装了好几遍babel-core还是不行。对照以前的项目,发现babel-loader的版本不一样,之前的是@7.1.5版本,而现在是@8.0.0版本。 解决办法：降版本。。。npm uninstall babel-loader npm install babel-loader@7.1.5 官方文档说：官方默认babel-loader | babel 对应的版本需要一致: 即babel-loader需要搭配最新版本babel","categories":[{"name":"webpack","slug":"webpack","permalink":"http://onlyH.github.io/categories/webpack/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"感悟","slug":"感悟","permalink":"http://onlyH.github.io/tags/感悟/"}]},{"title":"rgb转化为16进制","slug":"rgb转为16进制","date":"2021-03-15T08:13:37.566Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/rgb转为16进制/","link":"","permalink":"http://onlyH.github.io/2021/03/15/rgb转为16进制/","excerpt":"项目中有个需求是写一个颜色选择器，默认有16个色块可以点击，用户也可以自己输入6位16进制字符，然后动态的给显示用户所输入的颜色。我采用的是vue的:class和:style去完成这个需求。做完之后，发现一个很尴尬的问题，如果我在输入框输入过值，那么他一定会覆盖clss的样式，也就是说，即使我点击色块，颜色也不会出现，于是想到一个解决办法，就是当我点击色块的时候，将色块的颜色值显示到输入框中。那么。如何获取到class中的css样式呢？？我采用了jquery的方法1var color = $(`.$&#123;item.color&#125;`).css('backgroundColor') //获取到颜色值 额。。。获取到的竟然是个rgb()…….转换起来12345var rgb = a.split(','); //将三个数值获取出var r = parseInt(rgb[0].split('(')[1]);//第一个值var g = parseInt(rgb[1]);//第二个值var b = parseInt(rgb[2].split(')')[0]);//第三个值var hex = \"#\" + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1); 原谅我没有把他封装起来。。。。。最后的hex就是rgb转换后的结果，也就是一个十六进制的色值。呼呼~~一定有比这个更简单的方法吧，思考中。。。","text":"项目中有个需求是写一个颜色选择器，默认有16个色块可以点击，用户也可以自己输入6位16进制字符，然后动态的给显示用户所输入的颜色。我采用的是vue的:class和:style去完成这个需求。做完之后，发现一个很尴尬的问题，如果我在输入框输入过值，那么他一定会覆盖clss的样式，也就是说，即使我点击色块，颜色也不会出现，于是想到一个解决办法，就是当我点击色块的时候，将色块的颜色值显示到输入框中。那么。如何获取到class中的css样式呢？？我采用了jquery的方法1var color = $(`.$&#123;item.color&#125;`).css('backgroundColor') //获取到颜色值 额。。。获取到的竟然是个rgb()…….转换起来12345var rgb = a.split(','); //将三个数值获取出var r = parseInt(rgb[0].split('(')[1]);//第一个值var g = parseInt(rgb[1]);//第二个值var b = parseInt(rgb[2].split(')')[0]);//第三个值var hex = \"#\" + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1); 原谅我没有把他封装起来。。。。。最后的hex就是rgb转换后的结果，也就是一个十六进制的色值。呼呼~~一定有比这个更简单的方法吧，思考中。。。","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"ES6系列-模块化","slug":"module","date":"2021-03-15T08:13:37.565Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/module/","link":"","permalink":"http://onlyH.github.io/2021/03/15/module/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435export let A = 123; //导出一个变量export function test() &#123; console.log('test')&#125;export class Hello&#123; test() &#123; console.log('class') &#125;&#125;import &#123;A,test,Hello&#125; from './index'import * as lesson from './index'console.log(lesson.A)&#123; let A = 123; export function test() &#123; console.log('test') &#125; class Hello&#123; test() &#123; console.log('hello') &#125; &#125; export default&#123; A, test, Hello &#125; import 任意变量名 from './index'&#125;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"ES6系列-promise","slug":"promise","date":"2021-03-15T08:13:37.565Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/promise/","link":"","permalink":"http://onlyH.github.io/2021/03/15/promise/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136// promise&#123; //传统es5回调方式解决异步 let ajax = function (callback) &#123; console.log('等待下一步加载。。。') setTimeout(() =&gt; &#123; callback &amp;&amp; callback.call() &#125;, 1000); &#125; ajax(function () &#123; console.log('来了来了') &#125;)&#125;&#123; //执行a-b-c-d-e-f.... let ajax = () =&gt; &#123; console.log('等待setTimeOut2加载') return new Promise((resolve, reject) =&gt; &#123; //执行，中断 setTimeout(() =&gt; &#123; resolve() &#125;, 1000); &#125;) &#125; ajax().then(() =&gt; &#123; console.log('promise', 'setTimeOut2') &#125;)&#125;&#123; let ajax = () =&gt; &#123; console.log('等待第一次加载') return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, 1000); &#125;) &#125; ajax().then(() =&gt; &#123; console.log('等待第二次') return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, 2000); &#125;) &#125;) .then(() =&gt; &#123; console.log('我是第三次加载') return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, 3000); &#125;) &#125;) .then(() =&gt; &#123; console.log('最后一次加载') &#125;)&#125;//如果中间出现错误，如何捕获&#123; let ajax = function (num) &#123; console.log('判断num') return new Promise((resolve, reject) =&gt; &#123; if (num &lt; 5) &#123; resolve() &#125; else &#123; throw new Error('传错了') &#125; &#125;) &#125; ajax(6).then(() =&gt; &#123; console.log('log', 6) &#125;).catch(err =&gt; &#123; console.log('catch', err) &#125;) ajax(2).then(() =&gt; &#123; console.log('log', 2) &#125;).catch(err =&gt; &#123; console.log('catch', err) &#125;)&#125;//使用场景promise.all,promise&#123; // 所有图都加载后显示到页面 function loadImg(src) &#123; return new Promise((resolve, reject) =&gt; &#123; let img = document.createElement('img') img.src = src img.onload = () =&gt; &#123; resolve(img) &#125; img.onerror = () =&gt; &#123; reject(err) &#125; //图片加载完成onload &#125;) &#125; //添加到页面 function showImg(imgs) &#123; imgs.forEach(item =&gt; &#123; document.body.appendChild(item) &#125;) &#125; // promise.all把多个promise实例当成一个promise实例 Promise.all([ loadImg('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1545736426664&amp;di=219db669df4a813bcca53e582da7582e&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201706%2F12%2F20170612130531_wXcaQ.thumb.700_0.jpeg'), loadImg('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1545736426664&amp;di=2c20d892a361fa4313ae380600c434b8&amp;imgtype=0&amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn%2Fw440h329%2F20171229%2Fbe5c-fypyuve2937030.jpg'), loadImg('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1545736426663&amp;di=1ce727cefe866cd3baa0bcdc64dd8cb7&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201706%2F12%2F20170612130914_CrVz5.jpeg') ]).then(showImg)&#125;&#123; //先到先得,有一本图片加载完就加载到页面 function loadImg(src) &#123; return new Promise((resolve, reject) =&gt; &#123; let img = document.createElement('img') img.src = src img.onload = () =&gt; &#123; resolve(img) &#125; img.onerror = () =&gt; &#123; reject(err) &#125; &#125;) &#125; function showImg(imgs) &#123; document.body.appendChild(imgs) &#125; Promise.race([ loadImg('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1545736426664&amp;di=219db669df4a813bcca53e582da7582e&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201706%2F12%2F20170612130531_wXcaQ.thumb.700_0.jpeg'), loadImg('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1545736426664&amp;di=2c20d892a361fa4313ae380600c434b8&amp;imgtype=0&amp;src=http%3A%2F%2Fn.sinaimg.cn%2Fsinacn%2Fw440h329%2F20171229%2Fbe5c-fypyuve2937030.jpg'), loadImg('https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1545736426663&amp;di=1ce727cefe866cd3baa0bcdc64dd8cb7&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201706%2F12%2F20170612130914_CrVz5.jpeg') ]).then(showImg)&#125;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"js条件语句","slug":"js条件语句","date":"2021-03-15T08:13:37.564Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/js条件语句/","link":"","permalink":"http://onlyH.github.io/2021/03/15/js条件语句/","excerpt":"使用Array.includes来处理多重条件Array.includes 12345678910111213//badfunction test(fn) &#123; if(fn === 'apply' || fn == 'pear') &#123; console.log('yes') &#125;&#125;//如果筛选条件多function test(param) &#123; const fruits = ['apply','pear','banana'] //条件提取到数组 if(fruits.includes(param)) &#123; console.log('yes') &#125; &#125;","text":"使用Array.includes来处理多重条件Array.includes 12345678910111213//badfunction test(fn) &#123; if(fn === 'apply' || fn == 'pear') &#123; console.log('yes') &#125;&#125;//如果筛选条件多function test(param) &#123; const fruits = ['apply','pear','banana'] //条件提取到数组 if(fruits.includes(param)) &#123; console.log('yes') &#125; &#125; 少写嵌套，尽早返回 如果没有水果，抛出错误 如果该水果的数量大于10，将其打印出来1234567891011121314151617181920212223242526272829303132333435363738394041//badfunction test(param, num) &#123; const fruit = ['apple', 'pear', 'cherry'] // 条件 1：fruit 必须有值 if (param) &#123; // 条件 2：必须存在 if (fruit.includes(param)) &#123; console.log('red') //数量大于 10 if (num &gt; 10) &#123; console.log('more') &#125; &#125; &#125; else &#123; throw new Error('no frulte') &#125;&#125;// 测试结果test(null); // 报错：No fruitstest('apple'); //redtest('apple', 20) //redfunction test(p,num) &#123; const fruits = ['apply','pear'] if(!p) throw new Error('no') if(fruits.includes(p)) &#123; console.log('yes') if(num&gt;10) &#123; console.log('good') &#125; &#125;&#125;function test(p,num) &#123; const fruits = ['apply','pear','chreey'] if(!p) throw new Error('no') if(!fruits.includes(p)) return //不是直接返回 console.log('red') if(num&gt;10) console.log('good')&#125; 使用函数默认参数和解构1234567891011121314151617181920212223242526272829303132function test(fruit,num) &#123; if(!fruit) return let q = num || 1 console.log(`we have $&#123;q&#125; $&#123;fruit&#125;`)&#125;//测试结果test('banana'); // We have 1 banana!test('apple', 2); // We have 2 apple!function test(fruit,num = 1) &#123; if(!fruit) return console.log(`we have $&#123;fruit&#125; $&#123;num&#125;`) &#125; //如果fruit是一个对象function test(fruit) &#123; if(fruit &amp;&amp; fruit.name) &#123; console.log(fruit.name) &#125;else&#123; console.log('unknow') &#125; &#125;//测试结果test(undefined); // unknowntest(&#123; &#125;); // unknowntest(&#123; name: 'apple', color: 'red' &#125;); // apple//可以通过默认参数和解构赋值的方法来避免写出 fruit &amp;&amp; fruit.name 这种条件。function test(&#123;name&#125; =&#123;&#125;) &#123; console.log(name || 'unknow')&#125;//解构只适用于对象（Object） 相较于 switch，Map / Object 也许是更好的选择1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function test(color) &#123; switch(color) &#123; case 'red': return ['apple', 'strawberry']; case 'yellow': return ['banana', 'pineapple']; case 'purple': return ['grape', 'plum']; default: return []; &#125;&#125;//测试结果test(null); // []test('yellow'); // ['banana', 'pineapple']const fruit = &#123; red: ['apple', 'strawberry'], yellow: ['banana', 'pineapple'], purple: ['grape', 'plum']&#125;function test(color) &#123; return fruit[color] || [] &#125;//Mapconst fruit = new Map().set('red', ['apple', 'strawberry']).set('yellow', ['banana', 'pineapple']).set('purple', ['grape', 'plum']);function test(color) &#123; return fruit[color] || [] &#125;//Array.filterconst fruit = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'strawberry', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'pineapple', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;, &#123; name: 'plum', color: 'purple' &#125;]function test(color) &#123; return fruit.filter(f =&gt;f.color = color) &#125; 使用 Array.every 和 Array.some 来处理全部/部分满足条件123456789101112131415161718192021222324252627282930313233343536373839const fruits =[ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125; ]function test() &#123; let isAll = true //所有水果都必须是红色 for(let f of fruits) &#123; if(!isAll) break isAll = (f.color =='red') &#125; console.log(isAll) //false&#125;//Array.everyconst fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;]function test() &#123; //所有水果必须都是红色 const isAll = fruits.every(f =&gt;f.color =='red') console.log(isAll) //false &#125; //Array.some const fruits = [ &#123; name: 'apple', color: 'red' &#125;, &#123; name: 'banana', color: 'yellow' &#125;, &#123; name: 'grape', color: 'purple' &#125;]function test() &#123; //至少一个水果是红色 const isAll = fruits.some(f =&gt;f.color=='red') console.log(isAll) //true&#125;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"感悟","slug":"感悟","permalink":"http://onlyH.github.io/tags/感悟/"}]},{"title":"js日常使用","slug":"js日常","date":"2021-03-15T08:13:37.563Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/js日常/","link":"","permalink":"http://onlyH.github.io/2021/03/15/js日常/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111var text = 'purple haze'text['length']text.length//对象所扮演的主要角色实际上是一个属性的集合var cat = &#123; color:'gray', name:'spot', size:46&#125;cat.size; //46delete cat.size;cat.size;//undefindvar empty = &#123;&#125;empty.notReally = 1000empty;//&#123;notReally: 1000&#125;var thing = &#123; 'gabba':'hey', 5:10&#125;thing['5'] //10thing[2+3] //10//中括号会将表达式转化为字符串来判断是否有该属性的名称。//也可以把变量当成属性名称var propertyName = 'length'var text = 'coco'text[propertyName] //4//操作符in可以用来判断一个对象是否有某个属性，产生的是布尔值var chineseBox = &#123;&#125;chineseBox.content = chineseBox;'content' in chineseBox //truedebugger'content' in chineseBox.content//true//对象即集合var set = &#123;'spot':true&#125;set['white'] =true;delete set['spot']'aa' in set;//false//相同对象的两个引用和包含相同属性的两个不同对象是有区别的。var object1 = &#123;value:10&#125;var object2 = object1var object3 = &#123;value:10&#125;debugger;object1 == object2 //trueobject1 == object3 //false/* object1和object2是两个变量，抓取的是相同的值，这里只有一个实际对象，因此修改了object1的值，同时也改变了object2的值，object3指向的是另外一个对象，默认和object1有相同的属性，但各自单独运行比较对象时，js中的==操作符只有在赋予的两个值都完全相同时才能返回true，比较两个内容相同的不同对象将返回false*///对象即集合var arr = ['lele','tom','jack','shuan']for(var i of arr) &#123; console.log(`name:$&#123;i&#125;`)&#125;function range(item) &#123; var arr = [] for(var i = 0; i&lt;=item; i++) &#123; arr.push(i) &#125; return arr&#125;range(4) //01234// split()将一个字符串分解成一个数组var words = 'this is word'words.split(' ') //空格！！！// 如何测试一个段落是否以某个特定单词开头// charAt()---&gt;用于从某个字符串中获取指定的字符var cat = 'born 15-11-2003'cat.charAt(0) =='b' &amp;&amp; cat.charAt(1) == 'o' &amp;&amp; cat.charAt(2) =='r' &amp;&amp; cat.charAt(3) == 'n'//truecat.slice(0,4) =='born'//truefunction startsWidth(str,comp) &#123; return str.slice(0,comp.length) == comp&#125;//如果指定的位置没有字符，charAt将返回空字符，而slice则只是将不存在的内容忽略掉。//indexOf可以找出字符串第一次出现的位置或者截取字符串中的子串//如果slice只是一个参数，他将返回从指定位置一直到字符串结束位置之间的字符串function catName(paragraph) &#123; var colon = paragraph.indexOf(\":\"); return paragraph.slice(colon+2).split(\", \")&#125;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"ES6系列-Iterator与for of","slug":"Iterator-forOf","date":"2021-03-15T08:13:37.561Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/Iterator-forOf/","link":"","permalink":"http://onlyH.github.io/2021/03/15/Iterator-forOf/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* 什么是Iterator接口Iterator的基本用法for...of */&#123; let arr = ['hello', 'world'] let map = arr[Symbol.iterator]() console.log(map.next()) console.log(map.next()) console.log(map.next())// &#123;value: \"hello\", done: false&#125;// &#123;value: \"world\", done: false&#125;// &#123;value: undefined, done: true&#125;&#125;// 使用for..of循环Iterator&#123; let obj = &#123; start:[1,2,3], end:[4,5,6], [Symbol.iterator]() &#123; let that = this let index = 0 let arr = that.start.concat(that.end) let len = arr.length return &#123; next() &#123; if(index &lt;len) &#123; return &#123; value:arr[index++], done:false &#125; &#125;else&#123; return &#123; value:arr[index++], done:true &#125; &#125; &#125; &#125; &#125; &#125; for(let key of obj) &#123; console.log(key) &#125; // 1 // 2 // 3 // 4 // 5 // 6&#125;&#123; let arr = ['hello','world'] for(let value of arr) &#123; console.log(value) &#125; // hello // world&#125;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"html组件","slug":"html组件","date":"2021-03-15T08:13:37.560Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/html组件/","link":"","permalink":"http://onlyH.github.io/2021/03/15/html组件/","excerpt":"今日读了掘金上面的一篇文章，讲的是html组件。四大 Web 组件标准四大 Web 组件标准分别为：HTML Template、Shadow DOM、Custom Elements 和 HTML Imports。实际上其中一个已经被废弃了，所以变成“三大”了。","text":"今日读了掘金上面的一篇文章，讲的是html组件。四大 Web 组件标准四大 Web 组件标准分别为：HTML Template、Shadow DOM、Custom Elements 和 HTML Imports。实际上其中一个已经被废弃了，所以变成“三大”了。 HTML Template,简单的讲也就是 HTML5 中的&lt;template&gt; 标签，正常情况下它无色无味，感知不到它的存在，甚至它下面的 img 都不会被下载，script 都不会被执行。 就如它的名字一样，它只是一个模版，只有到你用到它时，它才会变得有意义。 Shadow DOM 则是原生组件封装的基本工具，它可以实现组件与组件之间的独立性。Custom Elements 是用来包装原生组件的容器，通过它，你就只需要写一个标签，就能得到一个完整的组件。 HTML Imports 则是 HTML 中类似于 ES6 Module 的一个东西，你可以直接 import 另一个 html 文件，然后使用其中的 DOM 节点。但是，由于 HTML Imports 和 ES6 Module 实在是太像了，并且除了 Chrome 以外没有浏览器愿意实现它，所以它已经被废弃并不推荐使用了。未来会使用 ES6 Module 来取代它，但是现在貌似还没有取代的方案，在新版的 Chrome 中这个功能已经被删除了，并且在使用的时候会在 Console 中给出警告。警告中说使用 ES Modules 来取代，但是我测试在 Chrome 71 中 ES Module 会强制检测文件的 MIME 类型必须为 JavaScript 类型，应该是暂时还没有实现支持。 Shadow DOMDOM，在 HTML 中作为一个最基础的骨架而存在，它是一个树结构，树上的每一个节点都是 HTML 中的一部分。DOM 作为一棵树，它拥有着上下级的层级关系，我们通常使用“父节点”、“子节点”、“兄弟节点”等来进行描述（当然有人觉得这些称谓强调性别，所以也创造了一些性别无关的称谓）。子节点在一定程度上会继承父节点的一些东西，也会因兄弟节点而产生一定的影响，比较明显的是在应用 CSS Style 的时候，子节点会从父节点那里继承一些样式。 而 Shadow DOM，也是 DOM 的一种，所以它也是一颗树，只不过它是长在 DOM 树上的一棵特殊的子树。 Shadow DOM 的特别之处就在于它致力于创建一个相对独立的一个空间，虽然也是长在 DOM 树上的，但是它的环境却是与外界隔离的，当然这个隔离是相对的，在这个隔离空间中，你可以选择性地从 DOM 树上的父节点继承一些属性，甚至是继承一棵 DOM 树进来。利用 Shadow DOM 的隔离性，我们就可以创造原生的 HTML 组件了。实际上，浏览器已经通过 Shadow DOM 实现了一些组件了，只是我们使用过却没有察觉而已，这也是 Shadow DOM 封装的组件的魅力所在：你只管写一个 HTML 标签，其他的交给我。（是不是有点像 React 的 JSX 啊？）1&lt;video controls src=\"./video.mp4\" width=\"400\" height=\"300\"&gt;&lt;/video&gt; 注：浏览器默认隐藏自身的 Shadow DOM 实现，但如果是用户通过脚本创造的 Shadow DOM，是不会被隐藏的。shadow DOM 中的节点大多都有 pseudo 属性，根据这个属性，你就可以在外面编写 CSS 样式来控制对应的节点样式了。比如，将上面这个pseudo=”-webkit-media-controls-overlay-play-button” 的 input 按钮的背景色改为橙色：123video::-webkit-media-controls-overlay-play-button &#123; background-color: orange;&#125; 由于 Shadow DOM 实际上也是 DOM 的一种，所以在 Shadow DOM 中还可以继续嵌套 Shadow DOM，就像上面那样。 浏览器中还有很多 Element 都使用了 Shadow DOM 的形式进行封装，比如 &lt;input&gt;、&lt;select&gt;、&lt;audio&gt; 等，这里就不一一展示了。由于 Shadow DOM 的隔离性，所以即便是你在外面写了个样式：div { background-color: red !important; }，Shadow DOM 内部的 div 也不会受到任何影响。 也就是说，写样式的时候，该用 id 的时候就用 id，该用 class 的时候就用 class，一个按钮的 class 应该写成 .button 就写成 .button。完全不用考虑当前组件中的 id、class 可能会与其他组件冲突，你只要确保一个组件内部不冲突就好——这很容易做到。 这解决了现在绝大多数的组件化框架都面临的问题：Element 的 class(className) 到底怎么写？用前缀命名空间的形式会导致 class 名太长，像这样：.header-nav-list-sublist-button-icon；而使用一些 CSS-in-JS 工具，可以创造一些唯一的 class 名称，像这样：.Nav__welcomeWrapper___lKXTg，这样的名称仍旧有点长，还带了冗余信息。 ShadowRootShadowRoot 是 Shadow DOM 下面的根，你可以把它当做 DOM 中的 一样看待，但是它不是 ，所以你不能使用 上的一些属性，甚至它不是一个节点。 你可以通过 ShadowRoot 下面的 appendChild、querySelectorAll 之类的属性或方法去操作整个 Shadow DOM 树。 对于一个普通的 Element，比如 &lt;div&gt;，你可以通过调用它上面的 attachShadow 方法来创建一个 ShadowRoot（还有一个 createShadowRoot 方法，已经过时不推荐使用），attachShadow 接受一个对象进行初始化：{ mode: &#39;open&#39; }，这个对象有一个 mode 属性，它有两个取值：’open’ 和 ‘closed’，这个属性是在创造 ShadowRoot 的时候需要初始化提供的，并在创建 ShadowRoot 之后成为一个只读属性。mode: ‘open’ 和 mode: ‘closed’ 有什么区别呢？在调用 attachShadow 创建 ShadowRoot 之后，attachShdow 方法会返回 ShadowRoot 对象实例，你可以通过这个返回值去构造整个 Shadow DOM。当 mode 为 ‘open’ 时，在用于创建 ShadowRoot 的外部普通节点（比如&lt;div&gt;）上，会有一个 shadowRoot 属性，这个属性也就是创造出来的那个 ShadowRoot，也就是说，在创建 ShadowRoot 之后，还是可以在任何地方通过这个属性再得到 ShadowRoot，继续对其进行改造；而当 mode 为 ‘closed’ 时，你将不能再得到这个属性，这个属性会被设置为 null，也就是说，你只能在 attachShadow 之后得到 ShadowRoot 对象，用于构造整个 Shadow DOM，一旦你失去对这个对象的引用，你就无法再对 Shadow DOM 进行改造了。 可以从上面 Shadow DOM 的截图中看到 #shadow-root (user-agent) 的字样，这就是 ShadowRoot 对象了，而括号中的 user-agent 表示这是浏览器内部实现的 Shadow DOM，如果使用通过脚本自己创建的 ShadowRoot，括号中会显示为 open 或 closed 表示 Shadow DOM 的 mode。 浏览器内部实现的 user-agent 的 mode 为 closed，所以你不能通过节点的 ShadowRoot 属性去获得其 ShadowRoot 对象，也就意味着你不能通过脚本对这些浏览器内部实现的 Shadow DOM 进行改造。 链接","categories":[{"name":"html","slug":"html","permalink":"http://onlyH.github.io/categories/html/"}],"tags":[{"name":"语言","slug":"语言","permalink":"http://onlyH.github.io/tags/语言/"},{"name":"理解","slug":"理解","permalink":"http://onlyH.github.io/tags/理解/"}]},{"title":"ES6系列-generator","slug":"generator","date":"2021-03-15T08:13:37.559Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/generator/","link":"","permalink":"http://onlyH.github.io/2021/03/15/generator/","excerpt":"","text":"generator基本定义,返回的结果类似于Iterator，其实就是返回的Iterator接口，当函数运行的时候，调用一次next(),会执行一个yield.一个遍历器生成函数，赋值给Symbol.iterator，从而使这个接口Iterator 任何一个iterator接口都会指向Symbol.iterator属性上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// 异步编程的解决方案&#123; let fn = function* () &#123; yield 'a' yield 'b' return 'c' &#125; let test = fn() console.log(test.next()) console.log(test.next()) console.log(test.next()) console.log(test.next()) // &#123;value: \"a\", done: false&#125; //&#123;value: \"b\", done: false&#125; //&#123;value: \"c\", done: true&#125; //&#123;value: undefined, done: true&#125;&#125;// 改写Iterator，使用for..of循环对象&#123; let obj = &#123;&#125; obj[Symbol.iterator] = function* () &#123; yield 1 yield 2 yield 3 &#125; for (let value of obj) &#123; console.log(value) &#125; /* 1 2 3 */&#125;// 什么时候优势最大 -- 状态机 a-b-c-a...&#123; let state = function* () &#123; while (1) &#123; yield 'a' yield 'b' yield 'c' &#125; &#125; let status = state() console.log(status.next()) console.log(status.next()) console.log(status.next()) console.log(status.next()) console.log(status.next()) // &#123;value: \"a\", done: false&#125; // &#123;value: \"b\", done: false&#125; // &#123;value: \"c\", done: false&#125; // &#123;value: \"a\", done: false&#125; // &#123;value: \"b\", done: false&#125;&#125;// 语法糖 async&#123; let state = async function () &#123; while (1) &#123; await 'a'; await 'b'; await 'c'; &#125; &#125; let status = state() console.log(status.next()) console.log(status.next()) console.log(status.next()) console.log(status.next()) console.log(status.next())&#125;// 抽奖逻辑&#123; let draw = count =&gt; &#123; //具体逻辑。。 console.log(`还剩下$&#123;count&#125;次`) &#125; let residus = function* (count) &#123; while (count &gt; 0) &#123; count--; yield draw(count) &#125; &#125; let start = residus(5) //5为从后台取得值 let btn = document.createElement('button') btn.innerHTML = '按钮' btn.id = 'startBtn' document.body.appendChild(btn) btn.addEventListener('click', function () &#123; start.next() &#125;, false)&#125;&#123; //长轮询 let ajax = function* () &#123; yield new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reslove(&#123; code: 1 &#125;) &#125;, 200); &#125;) &#125; let pull = () =&gt; &#123; let generator = ajax() let step = generator.next() step.value.then(d =&gt; &#123; if (d.value != 0) &#123; setTimeout(() =&gt; &#123; console.log('wait') &#125;, 1000); &#125; else &#123; console.log(d) &#125; &#125;) &#125;&#125;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"gulp了解","slug":"gulp","date":"2021-03-15T08:13:37.559Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/gulp/","link":"","permalink":"http://onlyH.github.io/2021/03/15/gulp/","excerpt":"","text":"安装 gulp $ npm install --global gulp 任务管理文件 gulpfile.js 12345678//引入const gulp = require('gulp')const shelljs = require('shelljs')//定义任务，默认defaultgulp.task('default',()=&gt;&#123; // console.log('this is deafult') //执行&#125;) 运行 $ gulp","categories":[{"name":"gulp","slug":"gulp","permalink":"http://onlyH.github.io/categories/gulp/"}],"tags":[{"name":"感悟","slug":"感悟","permalink":"http://onlyH.github.io/tags/感悟/"},{"name":"语言","slug":"语言","permalink":"http://onlyH.github.io/tags/语言/"}]},{"title":"ES6系列-decorator","slug":"decorator","date":"2021-03-15T08:13:37.557Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/decorator/","link":"","permalink":"http://onlyH.github.io/2021/03/15/decorator/","excerpt":"","text":"decorator：修饰器是一个函数，修改行为，修改类的行为。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&#123; let readonly = (target, name, descriptor) =&gt; &#123; descriptor.writable = false return descriptor &#125; class Test &#123; @readonly time() &#123; return '2012-12-12' &#125; &#125; let test = new Test() test.time = () =&gt; &#123; console.log('reset time') &#125; console.log(test.time())&#125;&#123; let typename = (target, name, descriptor) =&gt; &#123; target.myname = 'hello' &#125; @typename class Test &#123; &#125; console.log('类的修饰', Test.myname)&#125;&#123; let log = (type) =&gt; &#123; return function (target, name, descriptor) &#123; let src_method = descriptor.value; descriptor.value = (...arg)=&gt;&#123; src_method.apply(target.arg); console.log(`log $&#123;type&#125;`) &#125; &#125; &#125; class AD&#123; @log('show') show() &#123; console.log('ad is show') &#125; @log('click') click() &#123; console.log('ad is click') &#125; &#125; let ad = new AD() ad.show() ad.click() /* ad is show log show ad is click log click */&#125;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"css奇技淫巧","slug":"css奇淫技巧","date":"2021-03-15T08:13:37.557Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/css奇淫技巧/","link":"","permalink":"http://onlyH.github.io/2021/03/15/css奇淫技巧/","excerpt":"","text":"在项目中总会遇到许多css问题，因此，总结几个常遇到的问题 placeholder移动:text-indent:3 去除input框:outline-style:none background渐变色 :background: linear-gradient(to bottom, #000000 0%,#ffffff 100%); 旋转180度带过渡:-webkit-transform: rotate(180deg);transition: All 0.4s ease-in-out; 关于垂直居中vertical-align可以设置像素值 在组件化的样式中，在类似于‘曰’这种布局的时候，如何动态的把线加载父元素上？12345678910111213141516.parent&#123; dispaly:flex; flex-direction:row; justify-content:space-around; box-sizing:border-box; &amp;:after&#123; content:''; display:block; width:100%; height:0; box-sizing:border-box; border-bottom:1px solid #ddd; position:relative; top:-208px; &#125;&#125;","categories":[{"name":"css","slug":"css","permalink":"http://onlyH.github.io/categories/css/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"运行babel，webpack，rollop.js用法","slug":"babel运行","date":"2021-03-15T08:13:37.556Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/babel运行/","link":"","permalink":"http://onlyH.github.io/2021/03/15/babel运行/","excerpt":"运行 npm init -y npm i --save-dev babel-core babel-preset-es2015 babel-preset-latest 创建.babelrc npm install --save-dev babel-cli本地就不能用 babel 命令了，在 package.json 文件中添加： 12345&#123; \"script\": &#123; \"build\": \"babel src -d lib\" &#125;&#125; 创建 ./src/index.js 12345678910111213把babel-preset-es2015换成babel-preset-envbabel-preset-env包括了之前的：babel-preset-es2015, babel-preset-es2016, babel-preset-es2017babel-preset-latest其他社区的es20xxbabel-preset-node5, babel-preset-es2015-node, 等等// \"build\": \"babel src -d lib\", 开发环境 webpacknpm i webpack babel-loader --save-dev 配置webpack.config.js 配置package.json中的script 运行 npm start 运行项目需要安装webpack-dev-server，webpack4x后要区分development和production不支持loader-core@8，需要卸载npm un loader-core安装npm i --save-dev babel-loader@7 rollup.js &lt;—-react,vue都是这样打包的","text":"运行 npm init -y npm i --save-dev babel-core babel-preset-es2015 babel-preset-latest 创建.babelrc npm install --save-dev babel-cli本地就不能用 babel 命令了，在 package.json 文件中添加： 12345&#123; \"script\": &#123; \"build\": \"babel src -d lib\" &#125;&#125; 创建 ./src/index.js 12345678910111213把babel-preset-es2015换成babel-preset-envbabel-preset-env包括了之前的：babel-preset-es2015, babel-preset-es2016, babel-preset-es2017babel-preset-latest其他社区的es20xxbabel-preset-node5, babel-preset-es2015-node, 等等// \"build\": \"babel src -d lib\", 开发环境 webpacknpm i webpack babel-loader --save-dev 配置webpack.config.js 配置package.json中的script 运行 npm start 运行项目需要安装webpack-dev-server，webpack4x后要区分development和production不支持loader-core@8，需要卸载npm un loader-core安装npm i --save-dev babel-loader@7 rollup.js &lt;—-react,vue都是这样打包的 Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。Rollup 对代码模块使用新的标准化格式 npm init npm i rollup-plugin-node-resolve rollup-plugin-babel babel-plugin-external-helpers babel-preset-latest 配置 .babelrc 配置 rollup.config.js rollup与webpackrollup功能单一，webpack功能强大。工具要尽量功能单一，可集成，可扩展。","categories":[{"name":"babel","slug":"babel","permalink":"http://onlyH.github.io/categories/babel/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"css修改select样式","slug":"css修改select样式","date":"2021-03-15T08:13:37.556Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2021/03/15/css修改select样式/","link":"","permalink":"http://onlyH.github.io/2021/03/15/css修改select样式/","excerpt":"","text":"select是有默认样式的，select的一些默认样式我们很难修改，比如图标的替换。参考了一些别人的例子，整理下，如果要切换图片。1234&lt;select&gt; &lt;option value=\"1\"&gt;1&lt;/option&gt; &lt;option value=\"2\"&gt;2&lt;/option&gt; &lt;/select&gt; 123456789101112 select &#123; border: none; /*将默认的select选择框样式清除*/ appearance: none; -moz-appearance: none; -webkit-appearance: none; /*在选择框的最右侧中间显示小箭头图片*/ background: url(\"http://ourjs.github.io/static/2015/arrow.png\") no-repeat scroll right center transparent !important; /*为下拉小箭头留出一点位置，避免被文字覆盖*/ padding-right: 14px; outline: none;&#125;","categories":[{"name":"css","slug":"css","permalink":"http://onlyH.github.io/categories/css/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"title","slug":"title","date":"2019-06-24T11:09:11.000Z","updated":"2021-06-17T03:51:43.598Z","comments":true,"path":"2019/06/24/title/","link":"","permalink":"http://onlyH.github.io/2019/06/24/title/","excerpt":"","text":"test","categories":[],"tags":[]},{"title":"vue-动态组件","slug":"vue-动态组件","date":"2018-12-27T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/12/28/vue-动态组件/","link":"","permalink":"http://onlyH.github.io/2018/12/28/vue-动态组件/","excerpt":"让多个组件使用同一个挂载点，并动态切换，这就是动态组件。通过使用保留的 &lt;component&gt; 元素，动态地绑定到它的 is特性，我们让多个组件可以使用同一个挂载点，并动态切换。根据v-bind:is=&quot;组件名&quot;中的组件名去自动匹配组件，如果匹配不到则不显示。有一个功能需求，就是类似于官网上的动态组件的样子。点击会切换，在实现的过程中，有遇到问题，也请教了别人，记录下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 两个子组件txt，fileVue.component('txt',&#123; template:``, methods:&#123;// 子组件暴露给外界的值getValue: function () &#123; return &#123; type: 'text', content: this.inner &#125; &#125; &#125;, prop:[\"content\"]&#125;)Vue.component('file',&#123; template:``, methods:&#123;// 子组件暴露给外界的值getValue: function () &#123; return &#123; type: 'text', content: this.filesName &#125; &#125; &#125;, prop:[\"content\"]&#125;)// 父组件调用子组件 &lt;div class=\"despContainer\" v-for=\"(desp,index) in desps\"&gt; &lt;component :is=\"comps[desp.type]\" :content=\"desp\" :ref=\"'comp' + index\"/&gt;&lt;/div&gt;// desps的数据结构// props：// content:Object// inner:'xxx'// type:\"text\"// 父组件去循环，返回子组件暴露的值allDate() &#123; let data = []; for(let comp in this.desps) &#123; const comIns = this.$refs['comp'+comp][0] if(!comIns || typeof compIns.getValue !=='function')&#123; return &#125; if(compIns.getValue()) &#123; data.push(compIns.getValue()) &#125; &#125; return data&#125;// 调用let introduces = this.fetchAllData() 如果子组件要调用父组件的方法，可以使用\\$emit()传值，v-on 监听","text":"让多个组件使用同一个挂载点，并动态切换，这就是动态组件。通过使用保留的 &lt;component&gt; 元素，动态地绑定到它的 is特性，我们让多个组件可以使用同一个挂载点，并动态切换。根据v-bind:is=&quot;组件名&quot;中的组件名去自动匹配组件，如果匹配不到则不显示。有一个功能需求，就是类似于官网上的动态组件的样子。点击会切换，在实现的过程中，有遇到问题，也请教了别人，记录下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 两个子组件txt，fileVue.component('txt',&#123; template:``, methods:&#123;// 子组件暴露给外界的值getValue: function () &#123; return &#123; type: 'text', content: this.inner &#125; &#125; &#125;, prop:[\"content\"]&#125;)Vue.component('file',&#123; template:``, methods:&#123;// 子组件暴露给外界的值getValue: function () &#123; return &#123; type: 'text', content: this.filesName &#125; &#125; &#125;, prop:[\"content\"]&#125;)// 父组件调用子组件 &lt;div class=\"despContainer\" v-for=\"(desp,index) in desps\"&gt; &lt;component :is=\"comps[desp.type]\" :content=\"desp\" :ref=\"'comp' + index\"/&gt;&lt;/div&gt;// desps的数据结构// props：// content:Object// inner:'xxx'// type:\"text\"// 父组件去循环，返回子组件暴露的值allDate() &#123; let data = []; for(let comp in this.desps) &#123; const comIns = this.$refs['comp'+comp][0] if(!comIns || typeof compIns.getValue !=='function')&#123; return &#125; if(compIns.getValue()) &#123; data.push(compIns.getValue()) &#125; &#125; return data&#125;// 调用let introduces = this.fetchAllData() 如果子组件要调用父组件的方法，可以使用\\$emit()传值，v-on 监听 1234&lt;txt-component @check-title='checkTitle'/&gt;this.$emit('check-title', msg)","categories":[{"name":"vue","slug":"vue","permalink":"http://onlyH.github.io/categories/vue/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"功能","slug":"功能","permalink":"http://onlyH.github.io/tags/功能/"}]},{"title":"vue简易下拉框","slug":"vue下拉框","date":"2018-12-13T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/12/14/vue下拉框/","link":"","permalink":"http://onlyH.github.io/2018/12/14/vue下拉框/","excerpt":"使用vue模拟了一个简易的下拉框，主要是根据传入当前索引实现数据切换的。具体实现代码如下：12345678910111213 &lt;div class=\"dropdown show\"&gt; &lt;div class=\"dropdown-toggle\" @click=\"toggleDrop\" ref=\"listParents\"&gt; &#123;&#123;content.languages[nowIndex].name&#125;&#125; &lt;/div&gt; &lt;div class=\"drop\"&gt; &lt;a class=\"dropdown-item\" v-show=\"isDrop\" v-for=\"(ops,index) in content.languages\" :key=\"ops.id\" @click=\"chooseSelection(index)\"&gt;&#123;&#123;ops.name&#125;&#125;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627data()&#123; return &#123; isDrop:false, nowIndex:0, content&#123; languages:&#123; [ name:'lele', id:1 ], [ name:'xiaohong', id:2 ], &#125; &#125; &#125;&#125;,methods:&#123; toggleDrop() &#123; this.isDrop = !this.isDrop &#125;, chooseSelection(index) &#123; this.nowIndex = index; this.isDrop = false &#125;&#125; 关于点击空白处隐藏，具体实现的思路是：","text":"使用vue模拟了一个简易的下拉框，主要是根据传入当前索引实现数据切换的。具体实现代码如下：12345678910111213 &lt;div class=\"dropdown show\"&gt; &lt;div class=\"dropdown-toggle\" @click=\"toggleDrop\" ref=\"listParents\"&gt; &#123;&#123;content.languages[nowIndex].name&#125;&#125; &lt;/div&gt; &lt;div class=\"drop\"&gt; &lt;a class=\"dropdown-item\" v-show=\"isDrop\" v-for=\"(ops,index) in content.languages\" :key=\"ops.id\" @click=\"chooseSelection(index)\"&gt;&#123;&#123;ops.name&#125;&#125;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627data()&#123; return &#123; isDrop:false, nowIndex:0, content&#123; languages:&#123; [ name:'lele', id:1 ], [ name:'xiaohong', id:2 ], &#125; &#125; &#125;&#125;,methods:&#123; toggleDrop() &#123; this.isDrop = !this.isDrop &#125;, chooseSelection(index) &#123; this.nowIndex = index; this.isDrop = false &#125;&#125; 关于点击空白处隐藏，具体实现的思路是： 给document添加一个事件监听 当发生点击事件的时候判断点击的是否是当前对象（vue使用ref） 此段js写在mounted函数里面1234567mounted() &#123; document.addEventListener('click',e=&gt;&#123; if(!this.$refs.listParents.contains(e.target)) &#123; //这句是说如果我们点击到了listParents以外的区域 this.isDrop = false &#125; &#125;)&#125; 原生JS中是有contains方法的,但它并不是字符串方法，，仅用于判断DOM元素的包含关系，参数是Element类型JS中通用的contains方法判断两个节点的关系","categories":[{"name":"vue","slug":"vue","permalink":"http://onlyH.github.io/categories/vue/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"js替换json对象中的键名","slug":"js替换json对象中的键名","date":"2018-05-01T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/05/02/js替换json对象中的键名/","link":"","permalink":"http://onlyH.github.io/2018/05/02/js替换json对象中的键名/","excerpt":"","text":"使用map()是目前想到的最简单的办法。。 Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。Objects 和 maps 的比较12345678910var data = [ &#123;count:123,goods:'小米'&#125;, &#123;count:456,goods:'华为'&#125;, &#123;count:789,goods:'苹果'&#125;].map(item=&gt;&#123; return&#123; name:item.count, value:item.goods &#125;&#125;)","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"功能","slug":"功能","permalink":"http://onlyH.github.io/tags/功能/"}]},{"title":"关于JSON报错","slug":"jsonParse","date":"2018-04-30T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/05/01/jsonParse/","link":"","permalink":"http://onlyH.github.io/2018/05/01/jsonParse/","excerpt":"在项目代码中运用到了JSON.parse()和JSON.stringify()去转换保存对象this.editingFile = JSON.stringify(lesson)this.$set(this.lessons, index, JSON.parse(this.editingFile)) 每次新建进入页面的时候，都会报错Uncaught SyntaxError: Unexpected token u in JSON at position 0 Debugger后，发现每次新建的时候JSON.parse()里的参数是undefined","text":"在项目代码中运用到了JSON.parse()和JSON.stringify()去转换保存对象this.editingFile = JSON.stringify(lesson)this.$set(this.lessons, index, JSON.parse(this.editingFile)) 每次新建进入页面的时候，都会报错Uncaught SyntaxError: Unexpected token u in JSON at position 0 Debugger后，发现每次新建的时候JSON.parse()里的参数是undefined 查考得知，当参数为undefined的时候，JSON.parse()会报错的。解决办法是做判断。类似于：123if (this.editingFile != undefined) &#123; this.$set(this.lessons, index, JSON.parse(this.editingFile)) &#125; 以上是我的解决办法。","categories":[{"name":"json","slug":"json","permalink":"http://onlyH.github.io/categories/json/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"清空上传内容","slug":"上传多个file文件","date":"2018-04-27T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/04/28/上传多个file文件/","link":"","permalink":"http://onlyH.github.io/2018/04/28/上传多个file文件/","excerpt":"","text":"如果要上传同一个文件。例如&lt;input @change=&quot;fileChange(lesson, $event.target,index)&quot; type=&quot;file&quot; accept=&quot;.jpg,.png,.JPG,.PNG,.gif,.GIF,.xls,.xlsx,.ppt,.pptx,.doc,.docx,.txt,.pdf,.jpeg,.bmp,.XLS,.XLSX,.PPT,.PPTX,.DOC,.DOCX,.TXT,.PDF,.JPEG,.BMP&quot;&gt;12345678910111213fileChange: function (course, input, index) &#123; let fileObj = input.files[0]; var file = &#123; prepare: false,//是否可预览 name: fileObj.name, size: fileObj.size, previewFlag: false, process: true &#125;; course.files.push(file); input.value = \"\" &#125; 那么在js里只需要一行代码input.value = &quot;&quot;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"tab切换","slug":"tab切换","date":"2018-04-01T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/04/02/tab切换/","link":"","permalink":"http://onlyH.github.io/2018/04/02/tab切换/","excerpt":"","text":"使用javascript和jquery编写tab切换,使用jquery编写列表切换12345678910111213141516171819202122// javascriptfunction $(id) &#123; return typeof id == 'string' ? document.getElementById(id) : id&#125;window.onload = function () &#123; var titleName = $('tab-title').getelementsByTagName('li') var tabContent = $('tab-content').getelementsByTagName('div') if (titleName.length != tabContent.length) &#123; return &#125; for (var i = 0; i &lt; titleName.length; i++) &#123; titleName[i].id = i; titleName[i].onmouseover = function () &#123; for (var j = 0; j &lt; titleName.length; j++) &#123; titleName[j].className = '' titleName[j].style.display = 'none' &#125; this.className = 'select' tabContent[this.id].style.display = 'block' &#125; &#125;&#125; 1234567891011121314151617//jquery方法添加个定时器var timer;$(function () &#123; $('#tabfirst li').each(function (index) &#123; var liNode = $(this) $(this).mouseover(function () &#123; timer = setTimeout(() =&gt; &#123; $('div.content').removeClass('content') $('#tabfirst li.tabin').removeClass('tabin') $('div').eq(index).addClass('content') liNode.addClass('tabin') &#125;, 300); &#125;).mouseout(function () &#123; clearTimeout(timer) &#125;) &#125;)&#125;)() 1234567891011121314$(function () &#123; $('.list-1').bind('click', function () &#123; $('.list-1').css('backgroundPosition', '0px -26px') $('.list-2').css('backgroundPosition', '-30px -26px') $('changeList').children().removeClass('list-1-0').addClass('list-2-v') &#125;) $('.list-2').bind('click', function () &#123; $('.list-1').css('backgroundPosition', '0px 0px') $('.list-2').css('backgroundPosition', '-30px 0px') $('changeList').children().removeClass('list-2-v').addClass('list-1-0') &#125;)&#125;)()","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"功能","slug":"功能","permalink":"http://onlyH.github.io/tags/功能/"}]},{"title":"js八道题","slug":"js八道题","date":"2018-03-31T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/04/01/js八道题/","link":"","permalink":"http://onlyH.github.io/2018/04/01/js八道题/","excerpt":"1，写出判断一个变量变量名为arr是数组的方法。12345arr instanceof Arrayif(typeof arr.isArray == undefined) &#123; return Array.prototype.toString.call = ['object Array']&#125;//用一些数组方法去检测，比如slice() 2,一下代码输入的结果是？","text":"1，写出判断一个变量变量名为arr是数组的方法。12345arr instanceof Arrayif(typeof arr.isArray == undefined) &#123; return Array.prototype.toString.call = ['object Array']&#125;//用一些数组方法去检测，比如slice() 2,一下代码输入的结果是？12345678910111213141516var object = &#123; foo: 'bar', func:function() &#123; var self = this; console.log(this.foo); //bar console.log(self.foo); //bar (function() &#123; console.log(this.foo) //undefined console.log(self.foo) //bar &#125;)() &#125;&#125;object.func()//前两个的输出是因为在同一个作用域，this指向当前函数对象，第二次输出，因为是立即执行函数，所以this指向全局window，但是self指向的是当前作用域中的this//self这个变量会在整个func作用域中生效，同样，立即执行函数IIFE也在func作用域中，因此可以访问self，但IIFE由于缺乏对象this指向了window，但self提前保留了func的作用域this 3，请实现以下findList方法1234567891011121314151617181920212223var docs = [ &#123; id: 1, words: ['hello', 'world'] &#125;, &#123; id: 2, words: ['hello', 'China'] &#125;, &#123; id: 3, words: ['zzz', 'hello'] &#125;, &#123; id: 4, words: ['world', 'China'] &#125;];findList(docs, ['hello']) //1,2,3findList(docs, ['hello', 'world']) //1function findList(docs, arr) &#123; for (var i = 0; i &lt; docs.length; i++) &#123; var bin = false for (var j = 0; j &lt; arr.length; j++) &#123; var str = arr[j] if (docs[i].words.indexOf(str) == -1) &#123; bin = true &#125; &#125; if(!bin) &#123; console.log(docs[i].id) &#125; &#125;&#125; 4，移动端如何适配不同手机屏幕，有什么解决方案 目前知道的有百分比，rem，vh，flexible。。。 5，编写javascript深度克隆deepClone123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//浅拷贝var json1 = &#123; name: 'a', age:12, data:&#123; a:1, b:2 &#125;&#125;function copy(parent,child) &#123; var child = child || &#123;&#125; for(var i in parent) &#123; child[i] = parent[i] &#125; return child&#125;var json2 = copy(json1)json2.data.a = 3console.log(json1.data.a)//3console.log(json2.data.a)//3//深拷贝var json1 = &#123; name:'aa', age:12, data:&#123; a:1, b:2 &#125;&#125;function deepCopy(parent,child) &#123; var child = child || &#123;&#125; for(var i in parent) &#123; if(typeof parent[i] == 'object') &#123; child[i] = (parent[i].constructor === Array) ? [] : &#123;&#125; //child.data = &#123;&#125; deepCopy(parent[i],child[i]);//&#123;a:1,b:2&#125; 传过去的是child.data的空json &#125;else&#123; child[i] = parent[i]; //child.data.a .. &#125; &#125; return child&#125;var json2 = deepCopy(json1)json2.data.a = 3;console.log(json1.data.a) //1console.log(json2.data.a) //3 6，有一个数组a = [8, 10, 30, 55, 78, 90, 1]，新建一个数组b，b从a中一次随机选取一个元素，取完为止。12345678910var a = [8,10,30,55,78,90,1]var b = []for(var i = 0; i&lt;a.length;i++) &#123; var randomNum = Math.floor(Math.random() * a.length) //7个随机数 var newStr = a.splice(randomNum,1).toString() //随机删除一个，并且把它转换为字符串 console.log(newStr) i--; b.push(newStr)&#125;console.log(b) 7,假设发现有一篇文章，var content = “大量文字…”，过滤其中的敏感词汇，如何发现敏感词汇并将其背景标记为红色.12345678910//正则function filter(content) &#123; var result = '' var errWorld = ['坏','蠢'] for( var i = 0; i&lt;content.length;i++) &#123; var reg = new RegExp(errWorld[i],'ig') result = content.replace(reg,'') &#125; return result&#125; 8，编写sum()函数求和，非number类型参数需要进行过滤123456789101112function sum() &#123; var result = 0; for(var i = 0; i&lt;arguments.length;i++) &#123; if(isNaN(arguments[i])) &#123; continue &#125;else if(typeof arguments[i] === 'number')&#123;result +=arguments[i] &#125; &#125; return result&#125;sum(1,'aaaa',2,'ccc','2','33333',3)","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"感悟","slug":"感悟","permalink":"http://onlyH.github.io/tags/感悟/"}]},{"title":"购物车项目","slug":"购物车项目","date":"2018-03-31T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/04/01/购物车项目/","link":"","permalink":"http://onlyH.github.io/2018/04/01/购物车项目/","excerpt":"第一部分：购物功能123456789101112131415161718192021222324252627282930313233343536//接口json数据&#123; \"status\": 1, \"result\": &#123; \"totalMoney\": 88, \"list\": [ &#123; \"productId\": \"12345654321\", \"productName\": \"music\", \"productPrice\": \"28\", \"productQuentity\": 1, \"productImage\": \"img/goods.png\", \"parts\": [ &#123; \"partId\": \"100001\", \"partName\": \"see you again\" &#125; ] &#125;, &#123; \"productId\": \"12345654322\", \"productName\": \"food\", \"productPrice\": \"30\", \"productQuentity\": 1, \"productImage\": \"img/food.png\", \"parts\": [ &#123; \"partId\": \"100002\", \"partName\": \"ice\" &#125; ] &#125; ] &#125;, \"message\":\"\"&#125; 连接接口数据 123456789101112mounted:function() &#123; this.cartView();//实例化创建完以后，默认查询某一个方法&#125;methods:&#123; cartView() &#123; var that = this axios.get('/user.json?ID=12345') .then(function (response) &#123; that.productList = res.result.list &#125;) &#125;&#125; 列表数据渲染 123456789101112131415161718192021222324252627282930313233343536373839 &lt;!-- 购物车页面 --&gt;&lt;ul&gt; &lt;li v-for=\"(item,index) in productList\" :key=\"index\"&gt; &lt;!-- 选中状态 a --&gt; &lt;a href=\"javascript:;\" :class=\"&#123;'check':item.check&#125;\" @click=\"selectorPeoduct\"&gt;&lt;/a&gt; &lt;img :src=\"item.productImage\" alt=\"\"&gt; &lt;!-- titile --&gt; &lt;p&gt;&#123;&#123;item.productName&#125;&#125;&lt;/p&gt; &lt;!-- 类别 --&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd v-for=\"part in item.parts\" v-text=\"part.partsName\"&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;!-- 价格 --&gt; &lt;div&gt;&#123;&#123;item.productPrice | formatMoney&#125;&#125;&lt;/div&gt; &lt;!-- 个数 + - --&gt; &lt;a href=\"\" @click=\"changeNum(item,-1)\"&gt;+&lt;/a&gt; &lt;!--item对象--&gt; &lt;input type=\"text\" value=\"0\" v-model=\"item.productQuentity | money('元')\" disabled&gt; &lt;a href=\"\" @click=\"changeNum(item,1)\"&gt;-&lt;/a&gt; &lt;!-- 删除 --&gt; &lt;button @click=\"delConfirm(item)\"&gt;delete&lt;/button&gt; &lt;!-- 总金额 --&gt; &lt;div&gt;&#123;&#123;item.productPrice * item.productQuentity&#125;&#125;&lt;/div&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div&gt; &lt;span :class=\"&#123;'ckecked':checkAllFLag&#125;\" @click=\"checkAll(true)\"&gt;全选&lt;/span&gt; &lt;span @click=\"checkAll(false)\"&gt;取消全选&lt;/span&gt;&lt;/div&gt;&lt;!-- 删除后的弹框提示 --&gt;&lt;div :class=\"&#123;'show':delFlag&#125;\"&gt; &lt;button @click=\"delFlag = false\"&gt;关闭&lt;/button&gt; &lt;button @click=\"delProduct()\"&gt;确认删除&lt;/button&gt;&lt;/div&gt;&lt;!-- 结账 --&gt;&lt;a href=\"index.html\"&gt;&lt;/a&gt; 定义数据 123456789data() &#123; return&#123; totalMoney:0,//总金额 productList:[], checkAllFLag:false, delFlag:false, //遮罩开关 current:'' &#125;&#125; Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化 12345678910//局部filters:&#123; formatMoney:function(value) &#123; return \"￥\" + value.toFixed(2) &#125;&#125;//全局vue.filter('money',function(value,type)) &#123; return \"￥\" + value.toFixed(2) + type&#125; 改变商品数量 1234567891011changeMoney(product,way) &#123; if(way &gt; 0) &#123; product.productQuentity++ &#125;else&#123; product.productQuentity--; if(product.productQuentity&lt; 1) &#123; product.productQuentity = 1 &#125; &#125; this.totalPrice()&#125; 如果接口返回的数据中，没有判断点中状态的数据，那么就动态添加一个选中状态的判断。(多用于循环) 12345678910111213// :class一定是一个object 或者 数组selectorPeoduct(item) &#123; //判断商品是否选中 ,如果一个对象中的变量不存在，set方法 //判断item中的checked是否存在 if(typeof item.checked == 'undefined') &#123; //如果等于就是不存在 // 如果不存在，全局注册或者局部注册 Vue.set(item,'checked',true) this.$set(item,'checked',true) &#125;else&#123; item.checked = !item.checked &#125; this.totalPrice()&#125; 全选，取消全选事件 12345678910111213checkAll(flag) &#123; //参数用于判断当前状态是全选还是取消全选 this.checkAllFlag = flag var that = this this.productList.forEach(function(item,index) &#123; //如果第一次直接点击的全选，那么上面的事件就不会触发，checked属性就不存在。那么就要判断是否注册。 if(typeof item.checked == 'undefined') &#123; that.$set(item,'checked',this.checkAllFlag) &#125;else&#123; item .checked = this.checkAllFlag &#125; &#125;) this.totalPrice()&#125; 计算总金额 123456789totalPrice() &#123; var that = this; this.totalMoney = 0; this.productList.forEach(function(item,index) &#123; if(item.checked) &#123; that.totalMoney += item.productPrice * item.productQuentity &#125; &#125;)&#125; 删除操作（当前选中的是哪个要删除） 12345678910delConfirm(item) &#123; this.delFlag = true; this.current = item; //当前对象&#125;,delProduct() &#123; var index = this.productList.indexOf(this.current) //获取索引 this.productList.splice(index,1) this.delFlag = false&#125;","text":"第一部分：购物功能123456789101112131415161718192021222324252627282930313233343536//接口json数据&#123; \"status\": 1, \"result\": &#123; \"totalMoney\": 88, \"list\": [ &#123; \"productId\": \"12345654321\", \"productName\": \"music\", \"productPrice\": \"28\", \"productQuentity\": 1, \"productImage\": \"img/goods.png\", \"parts\": [ &#123; \"partId\": \"100001\", \"partName\": \"see you again\" &#125; ] &#125;, &#123; \"productId\": \"12345654322\", \"productName\": \"food\", \"productPrice\": \"30\", \"productQuentity\": 1, \"productImage\": \"img/food.png\", \"parts\": [ &#123; \"partId\": \"100002\", \"partName\": \"ice\" &#125; ] &#125; ] &#125;, \"message\":\"\"&#125; 连接接口数据 123456789101112mounted:function() &#123; this.cartView();//实例化创建完以后，默认查询某一个方法&#125;methods:&#123; cartView() &#123; var that = this axios.get('/user.json?ID=12345') .then(function (response) &#123; that.productList = res.result.list &#125;) &#125;&#125; 列表数据渲染 123456789101112131415161718192021222324252627282930313233343536373839 &lt;!-- 购物车页面 --&gt;&lt;ul&gt; &lt;li v-for=\"(item,index) in productList\" :key=\"index\"&gt; &lt;!-- 选中状态 a --&gt; &lt;a href=\"javascript:;\" :class=\"&#123;'check':item.check&#125;\" @click=\"selectorPeoduct\"&gt;&lt;/a&gt; &lt;img :src=\"item.productImage\" alt=\"\"&gt; &lt;!-- titile --&gt; &lt;p&gt;&#123;&#123;item.productName&#125;&#125;&lt;/p&gt; &lt;!-- 类别 --&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd v-for=\"part in item.parts\" v-text=\"part.partsName\"&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;!-- 价格 --&gt; &lt;div&gt;&#123;&#123;item.productPrice | formatMoney&#125;&#125;&lt;/div&gt; &lt;!-- 个数 + - --&gt; &lt;a href=\"\" @click=\"changeNum(item,-1)\"&gt;+&lt;/a&gt; &lt;!--item对象--&gt; &lt;input type=\"text\" value=\"0\" v-model=\"item.productQuentity | money('元')\" disabled&gt; &lt;a href=\"\" @click=\"changeNum(item,1)\"&gt;-&lt;/a&gt; &lt;!-- 删除 --&gt; &lt;button @click=\"delConfirm(item)\"&gt;delete&lt;/button&gt; &lt;!-- 总金额 --&gt; &lt;div&gt;&#123;&#123;item.productPrice * item.productQuentity&#125;&#125;&lt;/div&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div&gt; &lt;span :class=\"&#123;'ckecked':checkAllFLag&#125;\" @click=\"checkAll(true)\"&gt;全选&lt;/span&gt; &lt;span @click=\"checkAll(false)\"&gt;取消全选&lt;/span&gt;&lt;/div&gt;&lt;!-- 删除后的弹框提示 --&gt;&lt;div :class=\"&#123;'show':delFlag&#125;\"&gt; &lt;button @click=\"delFlag = false\"&gt;关闭&lt;/button&gt; &lt;button @click=\"delProduct()\"&gt;确认删除&lt;/button&gt;&lt;/div&gt;&lt;!-- 结账 --&gt;&lt;a href=\"index.html\"&gt;&lt;/a&gt; 定义数据 123456789data() &#123; return&#123; totalMoney:0,//总金额 productList:[], checkAllFLag:false, delFlag:false, //遮罩开关 current:'' &#125;&#125; Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化 12345678910//局部filters:&#123; formatMoney:function(value) &#123; return \"￥\" + value.toFixed(2) &#125;&#125;//全局vue.filter('money',function(value,type)) &#123; return \"￥\" + value.toFixed(2) + type&#125; 改变商品数量 1234567891011changeMoney(product,way) &#123; if(way &gt; 0) &#123; product.productQuentity++ &#125;else&#123; product.productQuentity--; if(product.productQuentity&lt; 1) &#123; product.productQuentity = 1 &#125; &#125; this.totalPrice()&#125; 如果接口返回的数据中，没有判断点中状态的数据，那么就动态添加一个选中状态的判断。(多用于循环) 12345678910111213// :class一定是一个object 或者 数组selectorPeoduct(item) &#123; //判断商品是否选中 ,如果一个对象中的变量不存在，set方法 //判断item中的checked是否存在 if(typeof item.checked == 'undefined') &#123; //如果等于就是不存在 // 如果不存在，全局注册或者局部注册 Vue.set(item,'checked',true) this.$set(item,'checked',true) &#125;else&#123; item.checked = !item.checked &#125; this.totalPrice()&#125; 全选，取消全选事件 12345678910111213checkAll(flag) &#123; //参数用于判断当前状态是全选还是取消全选 this.checkAllFlag = flag var that = this this.productList.forEach(function(item,index) &#123; //如果第一次直接点击的全选，那么上面的事件就不会触发，checked属性就不存在。那么就要判断是否注册。 if(typeof item.checked == 'undefined') &#123; that.$set(item,'checked',this.checkAllFlag) &#125;else&#123; item .checked = this.checkAllFlag &#125; &#125;) this.totalPrice()&#125; 计算总金额 123456789totalPrice() &#123; var that = this; this.totalMoney = 0; this.productList.forEach(function(item,index) &#123; if(item.checked) &#123; that.totalMoney += item.productPrice * item.productQuentity &#125; &#125;)&#125; 删除操作（当前选中的是哪个要删除） 12345678910delConfirm(item) &#123; this.delFlag = true; this.current = item; //当前对象&#125;,delProduct() &#123; var index = this.productList.indexOf(this.current) //获取索引 this.productList.splice(index,1) this.delFlag = false&#125; 第二部分：地址选配功能123456789101112131415161718192021222324//数据json&#123; \"status\": \"0\", \"message\": \"\", \"result\": [&#123; \"addressId\": \"100000\", \"userName\": \"jeck\", \"stressName\": \"北京市海淀区\", \"tel\": \"1232112321\", \"isDefault\": true &#125;, &#123; \"addressId\": \"100000\", \"userName\": \"jeck\", \"stressName\": \"北京市海淀区\", \"tel\": \"1232112321\", \"isDefault\": false &#125;, &#123; \"addressId\": \"100000\", \"userName\": \"jeck\", \"stressName\": \"北京市海淀区\", \"tel\": \"1232112321\", \"isDefault\": false &#125;]&#125; 列表数据渲染 123456789101112131415161718192021222324252627&lt;div&gt; &lt;span&gt;配送地址&lt;/span&gt; &lt;ul&gt; &lt;li v-for=\"(item,index) in filterLength\" @click=\"currentIndex = index\" :class=\"&#123;'check':currentIndex == index&#125;\"&gt; &lt;dl&gt; &lt;dt&gt;&#123;&#123;item.userName&#125;&#125;&lt;/dt&gt; &lt;dd&gt;&#123;&#123;item.stressName&#125;&#125;&lt;/dd&gt; &lt;dd&gt;&#123;&#123;item.tel&#125;&#125;&lt;/dd&gt; &lt;/dl&gt; &lt;div v-if=\"!item.isDefault\" @click=\"setDefault(item.addressId)\"&gt;设为默认&lt;/div&gt; &lt;div v-if=\"item.isDefault\"&gt;默认地址&lt;/div&gt; &lt;div @click=\"limitNum = addressList.length\"&gt;显示全部列表&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt; &lt;!-- 高亮 --&gt; &lt;div :class=\"&#123;'check':sippingMethod ==1&#125;\" @click=\"sippingMethod = 1\"&gt;标准配送&lt;/div&gt; &lt;div :class=\"&#123;'check':sippingMethod ==2&#125;\" @click=\"sippingMethod = 2\"&gt;高级配送&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 数据加载 1234567891011121314mounted:function() &#123; this.$nextTick(function() &#123; this.getAddressList() &#125;)&#125;,methods:&#123; getAddressList() &#123; var that = this axios.get('/address.json') .then(function (response) &#123; that.addressList = res.result.list &#125;) &#125;&#125; 定义data 12345678data() &#123; return&#123; addressList:[], limitNum:3, currentIndex:0,//定义卡片索引，做高亮 sippingMethod:1 //默认配送方式 &#125;&#125; 如果默认显示三张卡片 12345computed:&#123; filterLength:function() &#123; return this.addressList.slice(0,this.limitNum) &#125;&#125; 设为默认 123456789setDefault(addresssId) &#123; this.addressList.forEach(function(address,index) &#123; if(address.addressId == addressId) &#123; address.isDefault = true &#125;else&#123; address.isDefault = false &#125; &#125;)&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://onlyH.github.io/categories/vue/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://onlyH.github.io/tags/项目/"},{"name":"项分析目","slug":"项分析目","permalink":"http://onlyH.github.io/tags/项分析目/"}]},{"title":"js中的内置函数","slug":"内置函数","date":"2018-03-27T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/03/28/内置函数/","link":"","permalink":"http://onlyH.github.io/2018/03/28/内置函数/","excerpt":"","text":"js中有哪些内置函数？–函数封装类对象 123456789ObjectArrayBoolearnStringFunctionErrorNumberDateRegExp","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"逻辑运算符","slug":"逻辑运算符","date":"2018-03-27T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/03/28/逻辑运算符/","link":"","permalink":"http://onlyH.github.io/2018/03/28/逻辑运算符/","excerpt":"","text":"123456789101112131415console.log(10 &amp;&amp; 0) //0console.log('' || 'abc') //abcconsole.log(window.abc) //true//判断一个变量会被当做true还是falsevar a = 100;console.log(!!a)var a = &#123;&#125;if(a.b == null) &#123; //a.b === null ,a.b === undefined&#125;//参考于bootstrap源码","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"vue日常学习-router","slug":"vue-router","date":"2018-03-01T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/03/02/vue-router/","link":"","permalink":"http://onlyH.github.io/2018/03/02/vue-router/","excerpt":"","text":"今日搭建vue 3.0脚手架，写了个小项目，被一个问题卡了半天，就是在app.vue里面的router-view和router-link无法生效，页面不会跳转并且控制台会报错，请教后得知，自己在router.js里配置路由的时候代码写错了1234567891011121314151617181920212223242526//错误代码&#123; path: '/shopping', name: 'shopping', component: () =&gt; &#123; import(\"./components/shopping\") &#125; &#125; //正确的写法 1&#123; path: '/shopping', name: 'shopping', component: () =&gt; import(\"./components/shopping\") &#125;//正确的写法 2&#123; path: '/shopping', name: 'shopping', component: () =&gt; &#123; return import(\"./components/shopping\") &#125; &#125;//import是个异步函数, 单纯的componet方法没有返回值,如果加了&#123;&#125;，需要使用return返回出去","categories":[{"name":"vue","slug":"vue","permalink":"http://onlyH.github.io/categories/vue/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"感悟","slug":"感悟","permalink":"http://onlyH.github.io/tags/感悟/"}]},{"title":"vue日常学习","slug":"vue","date":"2018-02-28T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/03/01/vue/","link":"","permalink":"http://onlyH.github.io/2018/03/01/vue/","excerpt":"路由操作的基本步骤 1234567891011121314//引入对象import VueRouter from ’vue-router‘//安装插件Vue.use(VueRouter); //挂载属性的行为//创建理由对象let router = new VueRouter(&#123; routers:[&#123; name:'xxx',path:'/xxx',组件 &#125;]&#125;)//将路由对象放入到options中的 new Vue()new vue(&#123; router&#125;) 设置 1: &lt;router-link :to={name:’xxx’}&gt; 2: 配置路由规则{name:&#39;xxx&#39;,path:&#39;xxx&#39;,组件名} 3: 作了什么+ 在created事件函数中，获取路由参数 + 发起请求，把数据挂在上去 参数 查询字符串(#/beijing?id=1&amp;age=2)","text":"路由操作的基本步骤 1234567891011121314//引入对象import VueRouter from ’vue-router‘//安装插件Vue.use(VueRouter); //挂载属性的行为//创建理由对象let router = new VueRouter(&#123; routers:[&#123; name:'xxx',path:'/xxx',组件 &#125;]&#125;)//将路由对象放入到options中的 new Vue()new vue(&#123; router&#125;) 设置 1: &lt;router-link :to={name:’xxx’}&gt; 2: 配置路由规则{name:&#39;xxx&#39;,path:&#39;xxx&#39;,组件名} 3: 作了什么+ 在created事件函数中，获取路由参数 + 发起请求，把数据挂在上去 参数 查询字符串(#/beijing?id=1&amp;age=2) 1: &lt;router-link :to={name: ‘xxx’,query:{id=1,age=2}}&gt; 2: 配置路由规则{name:&#39;xxx&#39;,path:&#39;beijing&#39;,组件名} 3: 作了什么 + `this.$route.query.id || age` path(#/beijing/1/2 ) 1: &lt;router-link :to={name:’xxx’,params:{id:1,age:2}}&gt; 2: 配置路由规则{name:&#39;xxx&#39;,path:&#39;/beijing/:id/:age&#39;,组件名} 3: 作了什么+ `this.$route.params.id || age` 编程导航 一个获取信息的只读对象($route) 一个具备功能函数的对象($router) 根据浏览器历史记录前进和后退this.$router.go(-1 || 1) 跳转到指定路由this.$router.push({name:&#39;bj}) 嵌套路由 让变化的视图(router-view)产生包含关系(router-view) 让路由与router-view关联，并且产生父子关系 axios 合并请求 axios.all{[请求1，请求2]} 分发相应 axios.pread(fn) fn:对应参数和请求的顺序一致。 必须两次请求都成功，只要有一次失败就算失败，否则成功。12345678910111213141516171819202122232425262728293031323334//main.jsimport Vue from 'vue'import App from 'app'//引入import Axios from 'axios'Axios.defaults.baseURL = 'http://123.34.543/api/';//给Vue原型上挂载属性Vue.prototype.$axios = Axios//启动new Vue(&#123; el:'#app', render:c =&gt; c(App)&#125;)//app.vuecreated() &#123; function getMsg(res1,res2) &#123; console.log(res1) console.log(res2) &#125; this.$axios.all([ this.$axios.post('postcomment/300','content=123'), this.$axios.get('postcomment/300','content=123') ]) //分发相应 .then(this.$axios.spread(getMsg)) .catch(err =&gt;&#123; console.log(err) &#125;)&#125; 拦截器 过滤，再一次请求中，做操作,拦截器对每一次请求都有效 axios.interceptors.request.use(fn) 在请求之前 function(config) {} config相当于options对象 范围广12345678910111213141516//main.jsAxios.defaults.headers = &#123; accept:'defaults'&#125;//拦截器Axios.interceptors.request.use(function(config) &#123; console.log(config) //个性化修改 //config.headers.accept = 'interceptors' config.headers = &#123; accept:'interceptors' &#125; return config //返回没有修改的设置&#125;)//拦截器覆盖默认设置 1234567891011this.$axios.get('getcomments/300?pa=1',&#123; headers:&#123; accept:'get' &#125;&#125;).then(res =&gt;&#123;&#125;).catch(err =&gt;&#123;&#125;) token cookie和session的机制，coolie自带一个字符串 cookie只在浏览器 移动端原生应用，也可以使用http协议，可以加自定义的头，原生应用没有cookie 对于三端，token可以作为类似cookie的使用，并且可以通用 拦截器可以用在添加token上 拦截器操作 loading 在请求发起前open，在相应回来后close1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Axios.interceptors.request.use(function(config) &#123; //请求发起之前，显示loading return config&#125;)Axios.interceptors.response.use(function(config) &#123; //在相应回来之后，隐藏loading return config&#125;)``` #### 监听* watch可以对（单个）变量进行监视，也可以深度监视* 如果需求是对于10个变量进行监视？computed，可以监视多个，并且指定返回数据，并且可以显示在页面* 都是options中的根属性 - watch监视单个 - computed可以监视多个this相关属性值的改变，如果和原值一样，不会触发函数的调用，并且可以返回对象```javascript &lt;input type=\"text\" v-model=\"text\"&gt;&lt;button @click=\"changeValue\"&gt;&lt;/button&gt; data() &#123; return&#123; text:[], person:[&#123; name:'nick' &#125;,&#123; name:'lee' &#125;] &#125; &#125;, methods:&#123; changeValue() &#123; this.text = 'abc' this.person[0].name = 'tom' &#125; &#125;, watch:&#123; text:function (old,newV) &#123; console.log('change it') &#125;, person:&#123; handler:function (val,old) &#123; console.log('change it') &#125;, deep:true &#125; &#125; 123456789101112131415161718192021单价：&lt;input type=\"text\" v-model=\"price\"&gt;*件数：&lt;input type=\"text\" v-model=\"num\"&gt;*折扣：&lt;input type=\"text\" v-model=\"rate\"&gt;= &#123;&#123;sum.name&#125;&#125; &#123;&#123;sum.price&#125;&#125; data() &#123; return &#123; price: 0, num: 0, rate: 0 &#125; &#125;, computed: &#123; sum() &#123; //如果当函数内涉及到的this.相关属性发生变化后触发，并返回一个值（可以是对象） return &#123; name:'music', price:this.price * this.num * (this.rate / 100) &#125; &#125; &#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://onlyH.github.io/categories/vue/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"感悟","slug":"感悟","permalink":"http://onlyH.github.io/tags/感悟/"}]},{"title":"回调函数","slug":"回调函数","date":"2018-02-28T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/03/01/回调函数/","link":"","permalink":"http://onlyH.github.io/2018/03/01/回调函数/","excerpt":"","text":"js代码是顺序执行的，如果需要等到一个操作结束之后再进行下一个操作，这个时候需要用到回调函数 函数也是一种数据结构，可以像变量一样使用","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"感悟","slug":"感悟","permalink":"http://onlyH.github.io/tags/感悟/"}]},{"title":"axios配置","slug":"axios1","date":"2018-02-27T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/02/28/axios1/","link":"","permalink":"http://onlyH.github.io/2018/02/28/axios1/","excerpt":"","text":"123456789101112131415161718192021222324252627//引用import Axios from 'axios'//给vue原型挂载一个属性Vue.prototype.$axios = Axios// 初始化created() &#123; //get this.$axios.get('http://192.168.1.1') .then(res=&gt;&#123; console.log(res) this.data = this.data.message &#125;) .catch(err=&gt;&#123; console.log(err) &#125;) //post this.$axios.post('http://192.168.1.1',&#123;content:'hello world'&#125;, &#123; headers:&#123;'content-type':'appliction/x-www-form-urlencoded'&#125;&#125;) .then(res =&gt;&#123; this.data = res.data.message &#125;) .catch(err=&gt;&#123; &#125;)&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://onlyH.github.io/categories/vue/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"感悟","slug":"感悟","permalink":"http://onlyH.github.io/tags/感悟/"}]},{"title":"vue上传文件","slug":"vue_upfile","date":"2018-02-27T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/02/28/vue_upfile/","link":"","permalink":"http://onlyH.github.io/2018/02/28/vue_upfile/","excerpt":"","text":"例如点击标签&lt;span @click = &quot;addLesson&quot;&gt;&lt;/span&gt;上传文件1&lt;input @change=\"fileChange(lesson,$event.target)\" type=\"file\"&gt; 123456789101112131415161718addLesson:function() &#123; this.lessons.push(&#123; name:'', files:[], editing:true //需要隐藏的地方/显示的地方 &#125;)&#125; fileChange:function(course,input) &#123; let fileObj = input.file[0] let file = &#123; previewFlag:false, //是否可预览 name:fileObj.name, process:0, size:fileObj.size &#125;; course.files.push(file)&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://onlyH.github.io/categories/vue/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"关于遍历一组对象","slug":"遍历对象","date":"2018-02-27T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/02/28/遍历对象/","link":"","permalink":"http://onlyH.github.io/2018/02/28/遍历对象/","excerpt":"今日，要去遍历一组后台传来的数据，类似于12345678910111213courses: [0: &#123; classId: \"5b9b5a10a5084200d4905f98\", lessonId: \"5b9b5840a5084200d4905f8e\", courseName: \"sadfsafsadf\" &#125;1: &#123; classId: \"5b9b5a10a5084200d4905f98\", lessonId: \"5b9b584da5084200d4905f93\", courseName: \"sadfsafsadf\" &#125; 这样的数据。按照往常在vue里面动态展现数据的想法，我定义了一个空数组courseList = []，然后把后台的数据添加到这个空数组，如果是在vue中，一个 v-for=&quot;item in courseList&quot;就可以把数据展现了，但是我现在不是要在vue中展现，而是要js里面展现。采用定义空数组，然后把后台数据赋值给空数组，再去遍历空数组，获取需要的数据。。。orz，好放繁琐的一个过程。。现在，有一个新的做法，那就是 不在定义一个空数组，而是定义一个空对象，courseList = {} 出初始化这个对象，并把后台数据循环给这个对象的数组 接收传来的每一个对象12345678910111213141516//代码如下this.data.courseList = &#123;&#125;data.courses.forEach(course =&gt;&#123; //data.courses是后台数据 this.data.courseList[course.courseId] = course //course为每一组对象&#123;&#125;,&#123;&#125;,&#123;&#125;... //this.data.courseList将当前对象循环n次 //[course.courseId]数组，取每次循环中对应的courseId对应的数据&#125;)//这时候的 this.data.courseList[courseId]就等于courseList:Object5b9b5a10a5084200d4905f98:ObjectclassId:\"5b9b5a10a5084200d4905f98\"courseName:\"sadfsafsadf\"lessonId:\"5b9b584da5084200d4905f93\"5b9b5a2fa5084200d4905f9a:Object","text":"今日，要去遍历一组后台传来的数据，类似于12345678910111213courses: [0: &#123; classId: \"5b9b5a10a5084200d4905f98\", lessonId: \"5b9b5840a5084200d4905f8e\", courseName: \"sadfsafsadf\" &#125;1: &#123; classId: \"5b9b5a10a5084200d4905f98\", lessonId: \"5b9b584da5084200d4905f93\", courseName: \"sadfsafsadf\" &#125; 这样的数据。按照往常在vue里面动态展现数据的想法，我定义了一个空数组courseList = []，然后把后台的数据添加到这个空数组，如果是在vue中，一个 v-for=&quot;item in courseList&quot;就可以把数据展现了，但是我现在不是要在vue中展现，而是要js里面展现。采用定义空数组，然后把后台数据赋值给空数组，再去遍历空数组，获取需要的数据。。。orz，好放繁琐的一个过程。。现在，有一个新的做法，那就是 不在定义一个空数组，而是定义一个空对象，courseList = {} 出初始化这个对象，并把后台数据循环给这个对象的数组 接收传来的每一个对象12345678910111213141516//代码如下this.data.courseList = &#123;&#125;data.courses.forEach(course =&gt;&#123; //data.courses是后台数据 this.data.courseList[course.courseId] = course //course为每一组对象&#123;&#125;,&#123;&#125;,&#123;&#125;... //this.data.courseList将当前对象循环n次 //[course.courseId]数组，取每次循环中对应的courseId对应的数据&#125;)//这时候的 this.data.courseList[courseId]就等于courseList:Object5b9b5a10a5084200d4905f98:ObjectclassId:\"5b9b5a10a5084200d4905f98\"courseName:\"sadfsafsadf\"lessonId:\"5b9b584da5084200d4905f93\"5b9b5a2fa5084200d4905f9a:Object","categories":[{"name":"vue","slug":"vue","permalink":"http://onlyH.github.io/categories/vue/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"js五道题","slug":"js五道题","date":"2017-12-31T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2018/01/01/js五道题/","link":"","permalink":"http://onlyH.github.io/2018/01/01/js五道题/","excerpt":"第一题：1234if(!(\"a\" in window)) &#123; var a = 1&#125;alert(1) 所有的全局变量都是window属性，var a = 1 == window.a = 1检测变量是否声明变量 in window 所有的变量声明都在范围作用域的顶部,应该是变量提升吧 123456 alert('a' in window) var a;//等同于var a;alert('a' in window) 当变量声明和赋值在一起用的时候，js引擎会自动将他们分为两部分，声明和赋值，以便于将变量声明提前，不将赋值提前是因为他有可能影响代码执行处不可预期的结果。 123456//所以等同于var a;if(!('a' in window)) &#123; a = 1&#125;alert(a)","text":"第一题：1234if(!(\"a\" in window)) &#123; var a = 1&#125;alert(1) 所有的全局变量都是window属性，var a = 1 == window.a = 1检测变量是否声明变量 in window 所有的变量声明都在范围作用域的顶部,应该是变量提升吧 123456 alert('a' in window) var a;//等同于var a;alert('a' in window) 当变量声明和赋值在一起用的时候，js引擎会自动将他们分为两部分，声明和赋值，以便于将变量声明提前，不将赋值提前是因为他有可能影响代码执行处不可预期的结果。 123456//所以等同于var a;if(!('a' in window)) &#123; a = 1&#125;alert(a) 第二题：12345var a = 1, b = function a(x) &#123; x &amp;&amp; a(--x) &#125;alert(a) 变量声明在进入执行上下文就完成了 函数声明也是提前的，所有的函数声明都在执行代码之前都已经完成了声明，和变量声明一样。 12345678//函数声明function name(arr1,arr2) &#123; //...&#125;//函数表达式，相当于变量赋值，不是函数,函数表达式不会提前，等于普通的变量赋值var name = function(arr1,arr2) &#123; //...&#125; 函数声明会覆盖变量声明，但不会覆盖变量赋值，函数声明的优先级高于变量声明的优先级 123456789101112131415161718192021function value() &#123; return 1&#125;var value;alert(typeof value) //function//如果赋值了，变量赋值初始化就覆盖了函数声明function value() &#123; return 1&#125;var value = 2;alert(typeof value) //number``` - 这个函数是一个有名函数表达式，函数表达式不像函数声明一样可以覆盖变量声明，变量b是包含了该函数表达式，而这个函数表达式的名字是a，浏览器允许在函数内部调用a(--x),因为这个时候a在函数外面依然是数字，返回undefined。```javascriptvar a = 1, b = function(x) &#123; x &amp;&amp; b(--x) &#125;alert(1) //1 第三题：12345function a(x) &#123; return x * 2&#125;var a;alert(a) //undefined 函数声明 第四题：12345function b(x,y,a) &#123; arguments[2] = 10; alert(a)&#125;b(1,2,3) //10 活动对象是在进入函数上下文时被创建的，它通过函数的arguments属性初始化，arguments属性的值是arguments对象。arguments 对象是活动对象的一个属性，包括： callee指向当前函数的引用 length传递的参数的个数 properties-indexes（字符串类型的整数）属性的值就是函数的参数值，（左-&gt;右的顺序） properties-indexes内部元素的个数等于arguments.length.properties-index的值和实际传递过来的参数之间是共享的。这个共享不是真正的共享一个内存地址，而是两个不同的内存地址，使用js引擎来保证2个值是随时一样的，这个索引值要小于传入的参数的个数，如果只是传入了两个参数，使用arguments[2]赋值的话就会不一样。1234567891011121314function b(x,y,a) &#123; arguments[2] = 10; alert(a)&#125;b(1,2) //undefined//因为没有传递第三个参数a，所以赋值10以后，alert(a)的结果依然是undefinedfunction b(x,y,a) &#123; arguments[2] = 10; alert(arguments[2])&#125;b(1,2) //10//与a没有关系 第五题：1234function a() &#123; alert(this)&#125;a.call(null) this的定义1234567891011var obj = &#123; method: function() &#123; alert(this === obj) //true &#125;&#125;//当一个方法在对象上调用的时候，this就指向到了该对象上function method() &#123; alert(this === window) //true&#125;//当一个function的定义不是属于一个对象属性的时候（单独定义的函数），函数内部的this等价于window call call方法最为一个function执行，代表该方法可以让另外一个对象作为调用者来调用。 call方法的第一个参数是对象调用者，随后的其他参数是要传递给调用method的参数（声明的话）12345function method() &#123; alert(this === window)&#125;method() //truemethod.call(document) //false 如果第一个参数穿肚的对象调用者是null或者undefined，call方法将把全局对象（window）作为this的值。12345//理解如下function a() &#123; alert(this)&#125;a.call(window) //[object Window]","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"感悟","slug":"感悟","permalink":"http://onlyH.github.io/tags/感悟/"}]},{"title":"垃圾回收","slug":"垃圾回收","date":"2017-12-02T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/12/03/垃圾回收/","link":"","permalink":"http://onlyH.github.io/2017/12/03/垃圾回收/","excerpt":"代码回收规则 全局变量不会被回收 局部变量会被回收，函数一旦运行完毕，函数内部的东西会被销毁 只要被另外一个作用于所引用就不会被回收 12345678910var i = 1;var i = 2;var add = function() &#123; var i = 0; return function() &#123; i++; console.log(i) &#125;&#125;();add();","text":"代码回收规则 全局变量不会被回收 局部变量会被回收，函数一旦运行完毕，函数内部的东西会被销毁 只要被另外一个作用于所引用就不会被回收 12345678910var i = 1;var i = 2;var add = function() &#123; var i = 0; return function() &#123; i++; console.log(i) &#125;&#125;();add();","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"感悟","slug":"感悟","permalink":"http://onlyH.github.io/tags/感悟/"}]},{"title":"js高阶函数","slug":"js高阶函数","date":"2017-12-01T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/12/02/js高阶函数/","link":"","permalink":"http://onlyH.github.io/2017/12/02/js高阶函数/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170function greentng() &#123; console.log('hello world')&#125;greentng() //hello worldgreentng.lang = 'English'console.log(greentng.lang) //English//可以在 JavaScript 中将函数赋值给变量const square = function (x) &#123; return x * 2&#125;const total = square;total(4) //8//将函数作为参数传递function format(type, one, two) &#123; if (type == 'oneCase') &#123; one() &#125; else if (type == 'twoCase') &#123; two() &#125;&#125;function one() &#123; console.log('this is one')&#125;function two() &#123; console.log('this is two')&#125;format('oneCase', one, two)/* 高阶函数是对其他函数进行操作的函数，操作可以是将它们作为参数，或者是返回它们。 简单来说，高阶函数是一个接收函数作为参数或将函数作为输出返回的函数。 例如，Array.prototype.map，Array.prototype.filter 和 Array.prototype.reduce 是语言中内置的一些高阶函数。*//* Array.prototype.mapmap() 方法通过调用对输入数组中每个元素调用回调函数来创建一个新数组。map() 方法将获取回调函数中的每个返回值，并使用这些值创建一个新数组。传递给 map() 方法的回调函数接受 3 个参数：element，index 和 array。*/var num = [1, 2, 3, 4, 5]var arr = []for (var i = 0; i &lt; num.length; i++) &#123; arr.push(num[i] * 2)&#125;console.log(arr)// mapvar num = [1, 2, 3, 4]var arr = num.map(item =&gt; item * 2)console.log(arr)//假设我们有一个包含不同人的出生年份的数组，我们想要创建一个包含其年龄的数组。 例如：const year = [1993, 1923, 1983, 1990]const age = []for (var i = 0; i &lt; year.length; i++) &#123; let change = 2018 - year[i] age.push(change)&#125;console.log(age)// mapconst year = [1993, 1923, 1983, 1990]const age = year.map(item =&gt; 2018-item)console.log(age)/* Array.prototype.filterfilter() 方法会创建一个新数组，其中包含所有通过回调函数测试的元素。 传递给 filter() 方法的回调函数接受3个参数：element，index 和 array。*///假设我们有一个包含名称和年龄属性的对象数组。 我们想要创建一个只包含成年人（年龄大于或等于18）的数组。var persons = [ &#123;name:'peter',age:16&#125;, &#123;name:'lele',age:26&#125;, &#123;name:'shaun',age:18&#125;, &#123;name:'tony',age:46&#125;, &#123;name:'jack',age:54&#125;,]var adult = []for(var i = 0 ;i &lt;persons.length;i++) &#123; if(persons[i].age &gt;=18) &#123; adult.push(persons[i]) &#125;&#125;console.log(adult)//filtervar persons = [ &#123;name:'peter',age:16&#125;, &#123;name:'lele',age:26&#125;, &#123;name:'shaun',age:18&#125;, &#123;name:'tony',age:46&#125;, &#123;name:'jack',age:54&#125;,]var adult = persons.filter(item =&gt;item.age &gt;=18)console.log(adult)/* Array.prototype.reducereduce 方法对调用数组的每个元素执行回调函数，最后生成一个单一的值并返回。 reduce 方法接受两个参数：1）reducer 函数（回调），2）一个可选的 initialValue。 reducer 函数（回调）接受四个参数：accumulator，currentValue，currentIndex，sourceArray。 如果提供了 initialValue，则累加器将等于 initialValue，currentValue 将等于数组中的第一个元素。 如果没有提供 initialValue，则累加器将等于数组中的第一个元素，currentValue 将等于数组中的第二个元素。*///假设我们要对一个数字数组的求和：var sum = [1,2,3,4,5]var total = sum.reduce((a,b) =&gt; a+b)console.log(total)/* 每次对数组中的某个值调用 reducer 函数，累加器都会保留上一次 reducer 函数操作返回的结果，并将 currentValue 设置为数组的当前值。 最后把结果存储在 sum 变量中。我们还可以为它提供初始值：*/var num = [1,2,3,4]var total = 0;for(var i = 0 ;i &lt;num.length;i++) &#123; total +=num[i]&#125;console.log(total)//reducevar num = [1,2,3,4,5,6]var total = num.reduce((a,b) =&gt;&#123;return a+b&#125;,10)console.log(total)/* 我们假设 JavaScript 没有原生的 map 方法。我们可以自己构建它，从而创建我们自己的高阶函数。 假设我们有一个字符串数组，我们希望把它转换为整数数组，其中每个元素代表原始数组中字符串的长度。*/var strArray = ['javascript','python','php','java','c']function mapEach(arr,fn) &#123; var num = [] for(var i = 0; i&lt;arr.length;i++) &#123; num.push(fn(arr[i])) &#125; return num;&#125;var strLength = strArray.mapEach((strArray,()=&gt;))","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"this","slug":"this","date":"2017-12-01T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/12/02/this/","link":"","permalink":"http://onlyH.github.io/2017/12/02/this/","excerpt":"this12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 function identify() &#123; return this.name.toUpperCase(this) &#125; function speak() &#123; var greeting = 'hello' + identify.call(this) console.log(greeting) &#125; var me = &#123; name:'lele' &#125; var you = &#123; name:'tom' &#125; identify.call(me) identify.call(you) speak.call(me) speak.call(you) //这段代码可以在不同的上下文对象(me 和 you)中重复使用函数 identify() 和 speak()， 不用针对每个对象编写不同版本的函数。 //如果不使用 this，那就需要给 identify() 和 speak() 显式传入一个上下文对象。 function identify(context) &#123; return context.name.toUpperCase() &#125; function speak(context) &#123; var green = 'hello' + identify(context) console.log(green) &#125; identify(me) identify(you) function nums(i) &#123; console.log('nums' + i ); this.count++ &#125; foo.count = 0; for(var i = 0; i&lt;10;i++) &#123; if(i &gt; 5) &#123; nums(i) &#125; &#125; console.log(nums.count) function nums(i) &#123; console.log('nums' + i) data.count++ &#125; var data = &#123; count : 0 &#125; for(var i = 0; i&lt; 10;i++) &#123; if(i&lt;5) &#123; nums(i) &#125; &#125; console.log(data.count) //如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指 向函数对象的词法标识符(变量)来引用它。 function foo() &#123; foo.count = 4; //foo指向它自身 &#125; setTimeout(function() &#123; // 匿名(没有名字的)函数无法指向自身 &#125;,10)//第一个函数被称为具名函数，在它内部可以使用 foo 来引用自身。//但是在第二个例子中，传入 setTimeout(..) 的回调函数没有名称标识符(这种函数被称为 匿名函数)，因此无法从函数内部引用自身。//使用 foo 标识符替代 this 来引用函数 对象:function foo(num) &#123; console.log('foo' + num) foo.count++;&#125;foo.count = 0;for(var i = 0; i &lt; 10; i++) &#123; if(i &gt; 5) &#123; foo(i) &#125;&#125; 强制this指向foo函数对象12345678910function foo(num) &#123; console.log('num' + num) this.count++&#125;foo.count = 0;for(var i = 0; i &lt; 10; i++) &#123; if(i &gt; 5) &#123; foo.call(foo,i) &#125;&#125;","text":"this12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 function identify() &#123; return this.name.toUpperCase(this) &#125; function speak() &#123; var greeting = 'hello' + identify.call(this) console.log(greeting) &#125; var me = &#123; name:'lele' &#125; var you = &#123; name:'tom' &#125; identify.call(me) identify.call(you) speak.call(me) speak.call(you) //这段代码可以在不同的上下文对象(me 和 you)中重复使用函数 identify() 和 speak()， 不用针对每个对象编写不同版本的函数。 //如果不使用 this，那就需要给 identify() 和 speak() 显式传入一个上下文对象。 function identify(context) &#123; return context.name.toUpperCase() &#125; function speak(context) &#123; var green = 'hello' + identify(context) console.log(green) &#125; identify(me) identify(you) function nums(i) &#123; console.log('nums' + i ); this.count++ &#125; foo.count = 0; for(var i = 0; i&lt;10;i++) &#123; if(i &gt; 5) &#123; nums(i) &#125; &#125; console.log(nums.count) function nums(i) &#123; console.log('nums' + i) data.count++ &#125; var data = &#123; count : 0 &#125; for(var i = 0; i&lt; 10;i++) &#123; if(i&lt;5) &#123; nums(i) &#125; &#125; console.log(data.count) //如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指 向函数对象的词法标识符(变量)来引用它。 function foo() &#123; foo.count = 4; //foo指向它自身 &#125; setTimeout(function() &#123; // 匿名(没有名字的)函数无法指向自身 &#125;,10)//第一个函数被称为具名函数，在它内部可以使用 foo 来引用自身。//但是在第二个例子中，传入 setTimeout(..) 的回调函数没有名称标识符(这种函数被称为 匿名函数)，因此无法从函数内部引用自身。//使用 foo 标识符替代 this 来引用函数 对象:function foo(num) &#123; console.log('foo' + num) foo.count++;&#125;foo.count = 0;for(var i = 0; i &lt; 10; i++) &#123; if(i &gt; 5) &#123; foo(i) &#125;&#125; 强制this指向foo函数对象12345678910function foo(num) &#123; console.log('num' + num) this.count++&#125;foo.count = 0;for(var i = 0; i &lt; 10; i++) &#123; if(i &gt; 5) &#123; foo.call(foo,i) &#125;&#125;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"既可以输入又可以显示下拉的列表","slug":"显示下拉","date":"2017-12-01T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/12/02/显示下拉/","link":"","permalink":"http://onlyH.github.io/2017/12/02/显示下拉/","excerpt":"","text":"今日工作需求，写了一个既可以上传输入又可以下拉列表的输入框总结下这个功能的实现12345678910111213141516171819202122232425262728293031323334353637383940 &lt;input type=\"text\" id=\"selectId\" placeholder=\"Select Teacher\" v-model=\"teaName\" value=\"\" @click=\"selectTeacher\" class=\"form-control pr\"&gt; &lt;img src=\"/static/image/course-back.png\" class=\"course-select-img\" :class=\"&#123;'course-select-img-transform':teaSelect&#125;\"&gt; &lt;--下拉列表--&gt; &lt;div class=\"course-select \" v-show=\"teaSelect\"&gt; &lt;ul&gt; &lt;li v-for=\"(item,index) in filtedTeacher\" @click=\"selectOption(item)\"&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; //省略列表显示部分，着重记录下输入匹配的方法data() &#123; return&#123; teachers:[] //接收后台传来的对象 &#125;&#125;computed:&#123; let filtedTeacher = []; let inputName = this.teaName if(!inputName || !inputName.length) &#123; return this.teachers //把原数组返回 &#125;else&#123; for(var teacher of this.teachers) &#123; if(teacher.name.indexOf(inputName) !== -1) &#123; filtedTeacher.push(teacher) &#125; &#125; &#125;&#125;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"闭包","slug":"闭包","date":"2017-12-01T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/12/02/闭包/","link":"","permalink":"http://onlyH.github.io/2017/12/02/闭包/","excerpt":"当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 12345678910111213141516171819202122function foo() &#123; var a = 2; function bar() &#123; console.log(a) //2 &#125; bar()&#125;foo()function foo() &#123; var a = 2; function bar() &#123; console.log(a) &#125; return bar;&#125;var baz = foo();baz();//2 闭包//bar()的词法作用域能够与访问foo()的内部作用域，将bar()函数本身当做一个值类型进行传递（将bar所引用的函数对象本身当做返回值）在foo()执行后，其返回值(bar()函数)赋值给变量baz并调用baz()，实际上只是通过不同的标识符引用调用了内部的函数bar(),bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方 执行。//在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃 圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很 自然地会考虑对其进行回收。 闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此 没有被回收。谁在使用这个内部作用域?原来是 bar() 本身在使用。bar()拥有涵盖 foo() 内部作用域的闭包,使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。 bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到 闭包。12345678910111213141516171819202122232425262728function foo() &#123; var a = 2; function baz() &#123; console.log(a) //2 &#125; bar(baz)&#125;function bar(fn) &#123; fn()&#125;//把内部函数 baz 传递给 bar，当调用这个内部函数时(现在叫作 fn)，它涵盖的 foo()内部作用域的闭包就可以观察到了，因为它能够访问 a。var fn;function foo() &#123; var a = 2; function baz() &#123; console.log(a) &#125; fn = baz;//将 baz 分配给全局变量&#125;function bar() &#123; fn() //这就是闭包!&#125;foo()bar() //2//无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用 域的引用，无论在何处执行这个函数都会使用闭包。 经典123456function wait(message) &#123; setTimeout(function timer() &#123; console.log(message) &#125;,1000)&#125; wait('hello , closure ')","text":"当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 12345678910111213141516171819202122function foo() &#123; var a = 2; function bar() &#123; console.log(a) //2 &#125; bar()&#125;foo()function foo() &#123; var a = 2; function bar() &#123; console.log(a) &#125; return bar;&#125;var baz = foo();baz();//2 闭包//bar()的词法作用域能够与访问foo()的内部作用域，将bar()函数本身当做一个值类型进行传递（将bar所引用的函数对象本身当做返回值）在foo()执行后，其返回值(bar()函数)赋值给变量baz并调用baz()，实际上只是通过不同的标识符引用调用了内部的函数bar(),bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方 执行。//在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃 圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很 自然地会考虑对其进行回收。 闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此 没有被回收。谁在使用这个内部作用域?原来是 bar() 本身在使用。bar()拥有涵盖 foo() 内部作用域的闭包,使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。 bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到 闭包。12345678910111213141516171819202122232425262728function foo() &#123; var a = 2; function baz() &#123; console.log(a) //2 &#125; bar(baz)&#125;function bar(fn) &#123; fn()&#125;//把内部函数 baz 传递给 bar，当调用这个内部函数时(现在叫作 fn)，它涵盖的 foo()内部作用域的闭包就可以观察到了，因为它能够访问 a。var fn;function foo() &#123; var a = 2; function baz() &#123; console.log(a) &#125; fn = baz;//将 baz 分配给全局变量&#125;function bar() &#123; fn() //这就是闭包!&#125;foo()bar() //2//无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用 域的引用，无论在何处执行这个函数都会使用闭包。 经典123456function wait(message) &#123; setTimeout(function timer() &#123; console.log(message) &#125;,1000)&#125; wait('hello , closure ') 将一个内部函数(名为 timer)传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域的闭包，因此还保有对变量 message 的引用。wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait(..)作用域的闭包。深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个 参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是 内部的 timer 函数，而词法作用域在这个过程中保持完整。这就是闭包 1234567function setupBot(name,selector) &#123; $(selector).click(function activator() &#123; console.log(name) &#125;)&#125; setupBot( \"Closure Bot 1\", \"#bot_1\" ); setupBot( \"Closure Bot 2\", \"#bot_2\" ); 如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使 用了回调函数，实际上就是在使用闭包!通常认为 IIFE 是典型的闭包例子.12345var a = 2;(function IIEF() &#123; console.log(a)&#125;)()//这段代码可以正常工作，但严格来讲它并不是闭包。因为函数(示例代码中 的 IIFE)并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行(而外部作用域，也就是全局作用域也持有a)。a 是通过普通的词法作用域查找而非闭包被发现的。 循环和闭包–for循环1234567for(var i = 1 ;i&lt;=5; i++) &#123; setTimeout(function timer() &#123; console.log(i) &#125;,1000)&#125; //6,6,6,6,6//这个循环的终止条件是 i 不再 &lt;=5。条件首次成立时 i 的值是 6。因此，输出显示的是循环结束时 i 的最终值。//延迟函数的回调会在循环结束时才执行。事实上， 当定时器运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。 缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是 根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的， 但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。 这样说的话，当然所有函数共享一个 i 的引用。循环结构让我们误以为背后还有更复杂的 机制在起作用，但实际上没有。如果将延迟函数的回调重复定义五次，完全不使用循环， 那它同这段代码是完全等价的。 缺陷是什么?我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。 IIFE 会通过声明并立即执行一个函数来创建作用域。 IIEF如果作用域是空的，那么将它进行封闭是没有效果的，需要有一点实质内容才可以。12345678for(var i = 1 ; i&lt;=5; i++) &#123; (function (i) &#123; setTimeout(function timer() &#123; console.log(i) &#125;,i*1000) &#125;)(i)&#125; //在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 let劫持块作用域–并且在这个块作用域中声明了一个变量（将一个块转换成一个可以被关闭的作用域）12345for(let i = 1; i&lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i) &#125;,i*1000)&#125; 模块12345678910111213141516171819202122232425262728293031323334353637function foo() &#123; var something = 'cool' var other = [1,2,3] function doSomething() &#123; console.log(something) &#125; function doOther() &#123; console.log(other.join('!')) &#125;&#125;//这里并没有明显的闭包，只有两个私有数据变量 something 和 other，以及 doSomething() 和 doOther() 两个内部函数，它们的词法作用域(而这 就是闭包)也就是 foo() 的内部作用域。function coolModule() &#123; var something = 'study' var other = [1,2,3] function doSomething() &#123; console.log(something) &#125; function doOther() &#123; console.log(other.join('!')) &#125; return &#123; doSomething:doSomething, doOther : doOther &#125;&#125;var person = coolModule()person.doSomething()person.doOther()//这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露， 这里展示的是其变体。/*分析：1.coolModule()是一个函数，必须要通过调用他来创建一个模块实例，不执行外部函数，内部作用域和闭包都无法被创建2.coolModule()返回的是一个对象字面量语法&#123;key:value,...&#125;来表示的对象。这 个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐 藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共 API。3.这个对象类型的返回值最终被赋值给外部的变量 foo，然后就可以通过它来访问 API 中的 属性方法，比如 foo.doSomething()。4.doSomething() 和 doAnother() 函数具有涵盖模块实例内部作用域的闭包(通过调用 CoolModule() 实现)。当通过返回一个含有属性引用的对象的方式来将函数传递到词法作 用域外部时，我们已经创造了可以观察和实践闭包的条件。*/ 从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函 数。jQuery 就是一个很好的例子。jQuery 和 $ 标识符就是 jQuery 模块的公 共 API，但它们本身都是函数(由于函数也是对象，它们本身也可以拥有属性)。 模块模式需要具备两个必要条件 必须有外部的封闭函数，该函数必须至少被调用一次(每次调用都会创建一个新的模块 实例) 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用 所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块 上一个示例代码中有一个叫作 CoolModule() 的独立的模块创建器，可以被调用任意多次， 每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的 改进来实现单例模式:1234567891011121314151617var foo = (function coolModuel() &#123; var something = 'study' var other = [1,2,3] function doSomething() &#123; console.log(something) &#125; function doOther() &#123; console.log(other.join('!')) &#125; return &#123; doSomething:doSomething, doOther:doOther &#125;&#125;)()foo.doSomething()foo.doOther()//我们将模块函数转换成了 IIFE立即调用这个函数并将返回值直接赋值给 单例的模块实例标识符 foo。 模块也是普通的函数，因此可以接受参数:1234567891011function coolModule(id) &#123; function identify() &#123; console.log(id) &#125;return&#123; identify:identify &#125;&#125;var person1 = coolModule('teacher')var person2 = coolModule('doctor')person1.identify() //teacherperson2.identify() //doctor 模块模式另一个简单但强大的变化用法是，命名将要作为公共 API 返回的对象:12345678910111213141516171819202122var foo = (function coolModule(id) &#123; function change() &#123; // 修改公共 API publicAPI.identify = identify2 &#125; function identify1() &#123; console.log(id) &#125; function identify2() &#123; console.log(id.toUpperCase()) &#125; var publicAPI = &#123; change:change, identify:identify1 &#125; return publicAPI &#125;)('foo person') foo.identify()//foo person foo.change() foo.identify()//FOO PERSON//通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修 改，包括添加或删除方法和属性，以及修改它们的值。 现代的模块机制 大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。1234567891011121314151617var myModules = (function Manager() &#123; var modules = &#123;&#125; function define(name,deps,impl) &#123; for(var i = 0; i&lt;deps.length;i++) &#123; deps[i] = modules[deps[i]] &#125; modules[name] = impl.apply(impl,deps) &#125; function get(name) &#123; return modules[name] &#125; return &#123; define:define, get:get &#125;&#125;)()//这段代码的核心是 modules[name] = impl.apply(impl, deps)。为了模块的定义引入了包装函数(可以传入任何依赖)，并且将返回值，也就是模块的 API，储存在一个根据名字来管 理的模块列表中。 下面展示了如何使用它来定义模块:123456789101112131415161718192021myModules.define('bar',[],function() &#123; function hello(who) &#123; return 'let'+who &#125; return &#123; hello:hello &#125;&#125;)myModules.define('foo',['bar'],function(bar) &#123; var hungry = 'hippo'; function awesome() &#123; console.log(bar.hello(hungry).toUpperCase()) &#125; return&#123; awesome:awesome &#125;&#125;)var bar = myModules.get('bar')var foo = myModules.get('foo')console.log(bar.hello('hippo'))//Let hippo//\"foo\" 和 \"bar\" 模块都是通过一个返回公共 API 的函数来定义的。\"foo\" 甚至接受 \"bar\" 的 示例作为依赖参数，并能相应地使用它。 模块管理器:为函数定义引入包装函数，并保证它的返回值和模块的 API 保持一致 模块就是模块，即使在它们外层加上一个友好的包装工具也不会发生任何变化。 基于函数的模块并不是一个能被稳定识别的模式(编译器无法识别)，它们 的 API 语义只有在运行时才会被考虑进来。因此可以在运行时修改一个模块 的 API(参考前面关于公共 API 的讨论)。相比之下，ES6 模块 API 更加稳定(API 不会在运行时改变)。由于编辑器知 道这一点，因此可以在(的确也这样做了)编译期检查对导入模块的 API 成 员的引用是否真实存在。如果 API 引用并不存在，编译器会在运行时抛出一 个或多个“早期”错误，而不会像往常一样在运行期采用动态的解决方案. ES6 的模块没有“行内”格式，必须被定义在独立的文件中(一个文件一个模块)。浏览 器或引擎有一个默认的“模块加载器”(可以被重载)可以在导入模块时异步地加载模块文件。 1234567891011121314151617181920212223//bar.jsfunction hello(who) &#123; return 'Let me ' + who&#125;export hello//foo.js// 仅从 \"bar\" 模块导入 hello()import hello from 'bar'var hungry = 'hippo'function awesome() &#123; console.log(hello(hungry).toUpperCase())&#125;export awesome//baz.js// 导入完整的 \"foo\" 和 \"bar\" 模块module foo from 'foo'module bar from 'bar'console.log(bar.hello('rhino'))// Let me rhino foo.awesome();// LET ME : HIPPO//需要用前面两个代码片段中的内容分别创建文件 foo.js 和 bar.js。然后如第三 个代码片段中展示的那样，bar.js 中的程序会加载或导入这两个模块并使用 它们。 import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量 上(在我们的例子里是 hello)。module 会将整个模块的 API 导入并绑定到一个变量上(在 我们的例子里是 foo 和 bar)。export 会将当前模块的一个标识符(变量、函数)导出为公 共 API。这些操作可以在模块定义中根据需要使用任意多次。模块文件中的内容会被当作好像包含在作用域闭包中一样来处理模块 为创建内部作用域而调用了一个包装函数。 包装函数的返回 值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。 JavaScript 中的作用域就是词法 作用域(事实上大部分语言都是基于词法作用域的)词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段(假设你没有使用 eval() 或 with)。 123456789101112131415function foo() &#123; console.log(a) //2&#125;function bar() &#123; var a = 3 foo()&#125;var a = 2;bar()//词法作用域让 foo() 中的 a 通过 RHS 引用到了全局作用域中的 a，因此会输出 2。/*动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调 用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。 但是 this 机制某种程度上很像动态作用域。*/ 主要区别: 词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定 的。(this 也是!)词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 this 关注函数如何调用，这就表明了 this 机制和动态作用域之间的关系多么紧密 块作用域，而 with 和 catch 分句就是块作用域的两个小例子1234567891011121314&#123; let a = 2; console.log(a) //2&#125;console.log(a) //ReferenceError//参考如下try&#123; throw 2;&#125;catch(a) &#123; console.log(a)&#125;console.log(a) // ReferenceError//catch 分句具有块作用域，因此它可以在 ES6 之前的环境中作为块作用域的替代方案。 Traceur 的项目:123456789&#123; try&#123; throw undefined &#125;catch(a) &#123; a = 2; console.log(a) &#125;&#125;console.log(a) 隐式和显式作用域 let 作用域或 let 声明(1234let (a = 2) &#123; console.log(2)&#125; console.log( a ); // ReferenceError 同隐式地劫持一个已经存在的作用域不同，let 声明会创建一个显示的作用域并与其进行 绑定。显式作用域不仅更加突出，在代码重构时也表现得更加健壮。在语法上，通过强制 性地将所有变量声明提升到块的顶部来产生更简洁的代码。这样更容易判断变量是否属于 某个作用域。 let 声 明有意将变量声明放在块的顶部 箭头函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var foo = a =&gt;&#123; console.log(a)&#125;foo(2) //2var obj = &#123; id:'awesome', cool:function coolFn() &#123; console.log(this.id) &#125;&#125;var id = 'no cool'obj.cool() //coolsetTimeout(obj.cool,100)//no cool//cool() 函数丢失了同 this 之间的绑定,解决：var self = this ---词法作用域,self 只是一个可以通过 词法作用域和闭包进行引用的标识符，不关心 this 绑定的过程中发生了什么。var obj = &#123; count:0, cool:function () &#123; var self = this; if(self.count &lt; 1) &#123; setTimeout(function () &#123; self.count++; console.log('awesome') &#125;,100) &#125; &#125;&#125;obj.cool()//awesomevar obj = &#123; count:0, cool:function() &#123; if(this.count &lt;1) &#123; setTimeout(()=&gt;&#123; this.count++; console.log('yes') &#125;) &#125; &#125;&#125;obj.cool() //yesvar obj = &#123; count:0, cool:function() &#123; if(this.count &lt;1) &#123; setTimeout(function() &#123; this.count++;//this是安全的，因为bind() console.log('more awsome') &#125;.bind(this),100) &#125; &#125;&#125;obj.cool() 箭头函数的this是用当前的词法作用域覆盖了 this 本来的值。 《你不知道的javascript上卷》","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"作用域","slug":"作用域","date":"2017-11-30T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/12/01/作用域/","link":"","permalink":"http://onlyH.github.io/2017/12/01/作用域/","excerpt":"ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。12345678910111213//js具有基于函数的作用域，每声明一个函数都会为其自身创造一个气泡，而其他结构都不会创建作用域气泡，但并非完全真确function foo(a) &#123; var b = 2; //.. function bar() &#123; //.. &#125; //.. var c = 3&#125;// foo(..)包含了a,b,c,bar，所以无法从foo(..)的外部对他进行访问，这些标识符全都无法从全局作用域中进行访问。bar() //ReferenceErrorconsole.log(a,b,c) //ReferenceError 函数作用域：属于这个函数的全部变量都可以在整个函数的范围内使用及复用（嵌套的作用域中也可以使用）","text":"ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。12345678910111213//js具有基于函数的作用域，每声明一个函数都会为其自身创造一个气泡，而其他结构都不会创建作用域气泡，但并非完全真确function foo(a) &#123; var b = 2; //.. function bar() &#123; //.. &#125; //.. var c = 3&#125;// foo(..)包含了a,b,c,bar，所以无法从foo(..)的外部对他进行访问，这些标识符全都无法从全局作用域中进行访问。bar() //ReferenceErrorconsole.log(a,b,c) //ReferenceError 函数作用域：属于这个函数的全部变量都可以在整个函数的范围内使用及复用（嵌套的作用域中也可以使用）隐藏内部实现–最小特权：这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。123456789101112//变量 b 和函数 doSomethingElse(..) 应该是 doSomething(..) 内部具体 实现的“私有”内容function doSomething(a) &#123; function doSomethingElse(a) &#123; return a - 1; &#125; var b; b = a + doSomethingElse(a * 2); console.log(b * 3)&#125;doSomething(2) //15//b 和 doSomethingElse(..) 都无法从外部被访问，而只能被 doSomething(..) 所控制 全局命名空间 – 避免变量冲突，比如在全局作用域中声明一个独特的变量名，通常是一个对象（命名空间），所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。123456789var myRellyCoolLibrary = &#123; awesome:'stuff', doSomething:function() &#123; //.. &#125;, doAotherThing:function() &#123; //.. &#125;&#125; 函数作用域 –任意代码片段外部添加包装函数，科技将内部的变量和函数定义‘隐藏’起来，外部作用域无法访问包装函数内部的任何内容。12345678var a = 2;function foo() &#123; var a = 3; console.log(a) //3&#125;foo()console.log(a) //2// foo 被绑定在所在作用域中，可以直接通过foo() 来调用它 缺点：必须声明一个具名函数foo(),’污染’了作用域，必须要显式的通过调用函数名foo()才能运行。 参考以下方法12345678var a = 2;(function foo()&#123; var a = 3; console.log(a);//3&#125;)()console.log(a) //2// foo 被绑定在函数表达式自身的函数中而不是所在作用域中,此时函数会被当作函数表达式而不是一个标准的函数声明来处理。//(function foo()&#123; .. &#125;)作为函数表达式意味着foo只能在..所代表的位置中 被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作 用域。 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。 let–let 关键字可以将变量绑定到所在的任意作用域中，(通常是 {..}内部).123456789101112131415161718192021222324252627282930313233343536var foo = true;if(foo) &#123; let bar = foo * 2; bar = something(bar) console.log(bar)&#125;console.log(bar) //ReferenceError&#123;console.log( bar ); // ReferenceError! let bar = 2;&#125;function process(data) &#123; //..doSomething&#125;&#123; let someReally = &#123;..&#125; process(someReally)&#125;var btn = document.getElementById('div')btn.addEventListener('click',function(evt)&#123; console.log('button clicked')&#125;)for(let i = 0; i&lt;10;i++) &#123; console.log(i)&#125; console.log( i ); // ReferenceError//for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。&#123; let j; for(j = 0; j&lt;10;j++) &#123; let i = j; //// 每个迭代重新绑定! console.log(i) &#125;&#125; 由于 let 声明附属于一个新的作用域而不是当前的函数作用域(也不属于全局作用域)， 当代码中存在对于函数作用域中 var 声明的隐式依赖时，就会有很多隐藏的陷阱，如果用 let 来替代 var 则需要在代码重构的过程中付出额外的精力。 const123456789var foo = trueif(foo) &#123; var a = 2; const b = 3; a = 3;//ok b = 4;//no&#125;console.log(a);//3console.log(b);//PrferenceError 函数是 JavaScript 中最常见的作用域单元。 声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块(通常指 { .. } 内部)。 try/catch 结构在 catch 分句中具有块作用域。 提升 函数表达式不会提升，函数声明会123456789101112131415161718foo()var foo = function() &#123; console.log(a) //ubdefined var a = 2&#125;//理解如此function foo() &#123; var a; console.log(a);//undefined a = 2;&#125;foo()//理解如下var foo;foo();//TypeErrorfoo = function() &#123; //..&#125; 函数优先 函数会首先被提升，然后才是变量12345678910111213141516171819202122232425262728293031foo() //1var foo;function foo() &#123; console.log(1)&#125;foo = function() &#123; console.log(2)&#125;//理解如下function foo() &#123; console.log(1)&#125;foo() //1foo = function () &#123; console.log(2)&#125;//出现在后面的函数声明还是可以覆盖前面的foo() //3function foo() &#123; console.log(1)&#125;var foo = function() &#123; console.log(2)&#125;function foo() &#123; console.log(3)&#125;//一个普通块内部的函数声明通常会被提升到所在作用域的顶部 《你不知道的javascript上卷》","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"HTML-autocomplete","slug":"autocomplete","date":"2017-04-30T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/05/01/autocomplete/","link":"","permalink":"http://onlyH.github.io/2017/05/01/autocomplete/","excerpt":"","text":"项目中，手撸搜索框，从后台拿数据就行展示，选择操作等。偶然发现，搜索后，浏览器会有缓存。就是我的搜索会展示在页面上。于是。。查资料。。关于input的。。有这么一条属性autocomplete = off | no12345678定义和用法autocomplete 属性规定表单是否应该启用自动完成功能。自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。注释：autocomplete 属性适用于 &lt;form&gt;，以及下面的 &lt;input&gt; 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。提示：在某些浏览器中，您可能需要手动启用自动完成功能。 所以，我之所以有搜索记录存在，是因为浏览器会对同一个name标记的输入进行缓存，设置off瞬间解决掉问题。","categories":[{"name":"html","slug":"html","permalink":"http://onlyH.github.io/categories/html/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"}]},{"title":"ES6 理解api","slug":"es6","date":"2017-04-30T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/05/01/es6/","link":"","permalink":"http://onlyH.github.io/2017/05/01/es6/","excerpt":"12345678910111213141516171819202122232425262728293031323334353637383940414243function sum(x,y,z) &#123; let total = 0; if(x) total += x; if(y) total += y; if(z) total += z; console.log(`total:$&#123;total&#125;`)&#125;sum(1,'',2)function sum2(...m) &#123; //...rest参数，动态的，不确定的 let total = 0; for(var i of m) &#123; total += i &#125; console.log(`total:$&#123;total&#125;`)&#125;sum2(1,2,3) //不能传入字符串，否则会解析为字符串let sum3 =(...m) =&gt;&#123; let total = 0; for(var i of m) &#123; total += i; &#125; console.log(`total:$&#123;total&#125;`)&#125;sum3(1,2,3)var [x,y] = [4,8] //解构console.log(...[4,8]) //let arr1 = [1,2]let arr2 = [3,4]console.log(...arr1,...arr2)console.log([...arr1,...arr2]) //concatvar [x,...y] = [4,8,12,13] // y : 8,12,13let [a,b,c] = 'es6' //a:e,b:s,c:6let xy = [...'es6'] //拆解 …放函数里是rest参数，放数组里会进行运算，拆解1234567891011121314151617181920212223242526272829303132333435let checkLogin = function() &#123; return new Promise(function(resolve,reject) &#123; let flag = document.cookie.indexOf('userId') &gt; -1 ? true : false; if(flag) &#123; resolve(&#123; status:0, result:true &#125;) &#125;else&#123; reject('error') //报错 &#125; &#125;)&#125;;let getUserInfo = () =&gt; &#123; return new Promise((resolve,reject)=&gt;&#123; let userInfo = &#123;'101' &#125; resolve(userInfo); &#125;)&#125;checkLogin().then(res=&gt;&#123; if(res.status == 0) &#123; console.log('login'); return getUserInfo() &#125;&#125;).catch(error=&gt;&#123; console.log('error')&#125;).then((res2) =&gt;&#123; console.log(`userId:$&#123;userId&#125;`)&#125;)Promise.all([checkLogin(),getUserInfo()]).then(([res1,res2])=&gt;&#123; console.log(`result:`$&#123;res1.result&#125;)&#125;)","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243function sum(x,y,z) &#123; let total = 0; if(x) total += x; if(y) total += y; if(z) total += z; console.log(`total:$&#123;total&#125;`)&#125;sum(1,'',2)function sum2(...m) &#123; //...rest参数，动态的，不确定的 let total = 0; for(var i of m) &#123; total += i &#125; console.log(`total:$&#123;total&#125;`)&#125;sum2(1,2,3) //不能传入字符串，否则会解析为字符串let sum3 =(...m) =&gt;&#123; let total = 0; for(var i of m) &#123; total += i; &#125; console.log(`total:$&#123;total&#125;`)&#125;sum3(1,2,3)var [x,y] = [4,8] //解构console.log(...[4,8]) //let arr1 = [1,2]let arr2 = [3,4]console.log(...arr1,...arr2)console.log([...arr1,...arr2]) //concatvar [x,...y] = [4,8,12,13] // y : 8,12,13let [a,b,c] = 'es6' //a:e,b:s,c:6let xy = [...'es6'] //拆解 …放函数里是rest参数，放数组里会进行运算，拆解1234567891011121314151617181920212223242526272829303132333435let checkLogin = function() &#123; return new Promise(function(resolve,reject) &#123; let flag = document.cookie.indexOf('userId') &gt; -1 ? true : false; if(flag) &#123; resolve(&#123; status:0, result:true &#125;) &#125;else&#123; reject('error') //报错 &#125; &#125;)&#125;;let getUserInfo = () =&gt; &#123; return new Promise((resolve,reject)=&gt;&#123; let userInfo = &#123;'101' &#125; resolve(userInfo); &#125;)&#125;checkLogin().then(res=&gt;&#123; if(res.status == 0) &#123; console.log('login'); return getUserInfo() &#125;&#125;).catch(error=&gt;&#123; console.log('error')&#125;).then((res2) =&gt;&#123; console.log(`userId:$&#123;userId&#125;`)&#125;)Promise.all([checkLogin(),getUserInfo()]).then(([res1,res2])=&gt;&#123; console.log(`result:`$&#123;res1.result&#125;)&#125;) import,export123456789101112131415161718192021//utils.jsexport let sum = (x,y)=&gt;&#123; return x + y;&#125;export let sale = (m,n) =&gt;&#123; return m - n;&#125;//router.jsimport &#123;sum,sale&#125; from './utils'console.log(`sum:$&#123;sum(1,2)&#125;`)import *as util from './utils'console.log(`sum:`$&#123;util.sum(1,2)&#125;)// import可以异步加载 &lt;span @click=\"add\"&gt;&lt;/span&gt;add()&#123; import('./utils')&#125; AMD,CMD,CommonJs,ES6 模块化，规范，标准 AMD是requireJs在推广中对模块定义的规范化产出-同步模块定义 – 依赖前置 12345678define(['package/lib'],function(lib) &#123; function foo() &#123; lib.log('hello world') &#125; return &#123; foo:foo &#125;&#125;) CMD是SeaJs在推广过程中对模块定义的规范化产出-同步模块定义–依赖就近 123456//所有模块通过define来定义define(function(require,exports,module) &#123; //通过require引入依赖 var $ = require('jquery') var Spinning = require('./spinning')&#125;) commonJs—module.exports 在浏览器不支持 ==&gt;在node中使用123456exports.area = function() &#123; return Math.PI * r * r;&#125;exports.circumference = function() &#123; return 2 * Math.PI * r&#125; 解构赋值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&#123; let [a,b] = [1,2]&#125;&#123; let [a,b,c = 3] = [1,2,4] console.log(a,b,c)&#125;&#123; function sum() &#123; return [1,2] &#125; let [a,b] = sum()&#125;&#123; let &#123;a,b&#125; = &#123;a:1,b:2&#125;&#125;&#123; var list = &#123; title:'hello', core:[&#123; title:'tom', age:'34' &#125;,&#123; title:'lele', age:'22' &#125;] &#125; var &#123;title:newTitle,core:[&#123;title:contentTitle,age:contentAge&#125;]&#125; = list console.log(newTitle,contentTitle,contentAge) //hello tom 34&#125;&#123; var list = [&#123; title:'tom', age:'34' &#125;,&#123; title:'lele', age:'22' &#125;] for(var &#123;title:cTitle,age:cAge&#125; of list) &#123; console.log(cTitle,cAge)//tom 34 lele 22 &#125;&#125;&#123; let [a,,b] = [1,2,3] //1,3&#125;&#123; let [a,...b] = [1,2,3,4]//1,[2,3,4]&#125;&#123; let [a,b] = [2,3] console.log(b);//3 [b,a] = [a,b]; console.log(b)//2 &#125;&#123; let o = &#123; p:42, q:true &#125; let &#123;p,q&#125; = o console.log(p,q)&#125; 字符串扩展 1234567891011121314151617181920212223242526272829&#123; let str = 'string' console.log(str.includes('g'),str.startsWith('st'),str.endsWith('ng'))//true true true&#125;&#123; let str = 'string' console.log(str.repeat(2)) //stringstring&#125;&#123; // 补白 console.log('1'.padStart(2,'0')) console.log('1'.padEnd(2,'0'))&#125;&#123; // 标签模板 适用于多语言和xss攻击 let user = &#123; name:'Tom', age:'23' &#125; function person(s,v1,v2) &#123; return s + v1 + v2 &#125; person`i am $&#123;user.name&#125;,my age is $&#123;user.age&#125;`&#125; 数值扩展 123456789&#123; Number.isFinite(12) Number.isNaN(NaN) Number.isInteger(2) Number.isSafeInteger(2) //是否在有效范围之内 Math.trunc(3.2)//返回小数的整数部分,3 Math.sign(-5)//-1,0,1 ==&gt;判断是正数负数还是0 Math.cbrt(-2)&#125; 数组扩展Array.form,Array.of,copyWithin,find/findIndex,fill,entries/keys/values,inludes 12345678910111213141516171819202122232425262728293031323334let arr = Array.of(1,2,3,4,5) //把一组数据变量转化为数组类型// 把一些集合转化为数组Array.from([1,2,3,4,5],item=&gt;item*2) //2,4,6,8,10[1,2,3].fill(7) //[7,7,7][1,'a',undefined,3].fill(9) //(4) [9, 9, 9, 9][1,2,3,4,5,6,7].fill(8,1,3) [1,2,3,4,5,6,7].fill(8,1,3) //(7) [1, 8, 8, 4, 5, 6, 7]for(let index of [1,2,3,4,5].keys()) &#123; console.log(index) //0,1,2,3,4&#125;for(var val of ['a',1,'b'].values()) &#123; console.log(val) //a,1,b&#125;for(let [index,val] of [1,'a','cc',9].entries()) &#123; console.log(index,val)&#125;// 0 1// 1 \"a\"// 2 \"cc\"// 3 9[1,2,3,4,5].copyWithin(0,2,4) //(5) [3, 4, 3, 4, 5]//查找一个元素是否在一个数组中[1,2,3,4,5].find(item =&gt; item &gt; 3 ) //4 只找一个[1,2,3,4,5].findIndex(item =&gt;item &gt; 3) //返回当前符合元素的下标[1,2,3].includes(2)[NaN].includes(NaN) //true 函数扩展 123456789101112131415161718192021222324252627282930313233343536373839404142 function test(x,y = 'world') &#123; console.log(x,y) &#125; test() //undefined,worldlet x = 'one'function test(x,y = x) &#123; console.log(x,y)&#125;test('two') //two,twolet x = 'one'function test(c,y = x) &#123; console.log(x,y)&#125;test('two') //two,onefunction test(...args) &#123; for(let val of args) &#123; console.log(val) &#125;&#125;test(1,2,3,4,5) //1,2,3,4,5// 把数组转化为离散的值console.log(...[1,2,3])//合并console.log(...[1,3,4],...[9,8])let arrow = item =&gt;item * 2arrow(3) //6//尾调用function tail(x) &#123; console.log(x)&#125;function tx(x) &#123; return tail(x)&#125;tx(4) //4 对象扩展 1234567891011121314151617181920212223242526272829303132//简介表达式let name = 'lele'let age = 12let dog = &#123; name, age, &#125;//属性表达式let a = 'b'let es5 = &#123; a:'c', b:'c'&#125;let es6 = &#123; [a]:'c'&#125;console.log(es5,es6)//&#123;a: \"c\", b: \"c\"&#125;, &#123;b: \"c\"&#125;// 新增apiObject.is('abc','abc')Object.assign(&#123;a:1&#125;,&#123;b:'b'&#125;) //&#123;a: 1, b: \"b\"&#125;let test = &#123;k:123,v:456&#125;for(let [key,val] of Object.entries(test)) &#123; console.log(key,val)&#125;// k 123// v 456 Symbol 12345678910111213141516171819202122232425262728293031323334353637383940let a1 = Symbol()let a2 = Symbol()a1 == a2 //falselet a3 = Symbol.for('a3')let a4 = Symbol.for('a3')a3 == a4 //truelet aa = Symbol.for('abc')let obj = &#123; [aa]:123, 'abc':345, 'c':456&#125;console.log(obj)/* &#123;abc: 345, c: 456, Symbol(abc): 123&#125;abc: 345c: 456Symbol(abc): 123 */for(let [attr,val] of Object.entries(obj)) &#123; console.log(attr,val)&#125;/* abc 345c 456 不会循环到Symbol*/Object.getOwnPropertySymbols(obj).forEach(item=&gt;console.log(item,obj[item]))//Symbol(abc),123Reflect.ownKeys(obj).forEach(item=&gt;console.log(item))/*abccSymbol(abc) */ set-map结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180let a1 = new Set()a1.add(2)a1.add(3)add.size; //2&#123; let arr = [1,2,3,4] let list = new Set(arr) lise.size;//4 &#125;//可用于数组去重&#123; let arr = [1,2,1,2,1] let arr1 = Array.from(new Set(arr)) //[1, 2] arr instanceof Array //true&#125;&#123; let arr = ['add','delete','clear','has'] let list = new Set(arr) list.has('add') //true list.delete('add') //list ==&gt; &#123;\"delete\", \"clear\", \"has\"&#125; list.clear() //list ==&gt; &#123;&#125;&#125;//遍历for(let val of arr.values()) &#123; console.log(val)&#125;/* adddeleteclearhas */for(let attr of arr.keys()) &#123; console.log(attr)&#125;/* 0123 */for(let [attr,val] of arr.entries()) &#123; console.log(attr,val)&#125;/*0 \"add\"1 \"delete\"2 \"clear\"3 \"has\" */list.forEach(item =&gt;console.log(item))/* adddeleteclearhas */&#123; //weekSet()必须是对象，不会检测，不用担心内存泄漏，如果别的对象不引用该对象， 这个对象会被垃圾回收机制自动回收； let weakList = new WeakSet() let arg = &#123;&#125; weakList.add(arg) weakList.add(2) //报错 // 没有clear方法，没有set属性，不能遍历 console.log(weakList)&#125;&#123; let list = new Map() let arr = ['123'] list.set(arr,456) console.log(list,list.get(arr)) //Map(1) &#123;Array(1) =&gt; 456&#125; 456&#125;&#123; let map = new Map([['a',123],['b',456]]) console.log(map) //Map(2) &#123;\"a\" =&gt; 123, \"b\" =&gt; 456&#125; map.size; //2 map.delete('a') map.clear()&#125;&#123; let weakMap = new WeakMap() //===&gt;和WeakSet()相同&#125;// set-map与数组和对象的对比&#123; let map = new Map() let array = [] // 增 map.set('t',1) array.push(&#123;t:1&#125;) console.info(map,array) // Map(1) &#123;\"t\" =&gt; 1&#125; [&#123;t: 1&#125;] // 删 map.delete('t') let index = array.findIndex(item =&gt;item.t) array.splice(index,1) console.info(map,array) // Map(0) &#123;&#125; [] //改 map.set('t',2) // array['t'] = 2 array.forEach(item=&gt;item.t? item.t = 2:'') console.info(map,array) // Map(1) &#123;\"t\" =&gt; 2&#125; [t: 2] // 查 map.has('t') array.find(item=&gt;item.t) // Map(1) &#123;\"t\" =&gt; 2&#125; [t: 2]&#125;&#123; let set = new Set() let array = [] // 增 set.add('t',1) array.push(&#123;t:1&#125;) console.log(set,array) // &#123;\"t\" =&gt; 1&#125; [&#123;t: 1&#125;] // 删 set.delete('t') let index = array.forEach(item=&gt;item.t) array.splice(index,1) console.log(set,array) // 改 ==&gt;有问题 set.forEach(item=&gt;item.t?item.t = 2:'') array.forEach(item=&gt;item.t?item.t = 2:'') console.log(set,array) // 查 ==》有问题 set.has('t') console.log(set)&#125;&#123; let set = new Set() let map = new Map() let obj = &#123;&#125; // 增 set.add('t',1) map.set('t',1) obj['t'] = 1 console.log(set,map,obj) // Set(1) &#123;\"t\"&#125; Map(1) &#123;\"t\" =&gt; 1&#125; &#123;k: 1&#125; // 删 set.delete('t') map.delete('t') delete obj['t'] console.log(set,map,obj) //&#123;&#125;&#123;&#125;&#123;&#125; // 改 map.set('t',2) obj['t'] = 2 // 查 console.log(&#123; a: set.has('t'), b:map.has('t'), c:'t' in obj &#125;) //true true true&#125;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"ES6系列-proxy,Reflect","slug":"es6-proxy","date":"2017-04-30T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/05/01/es6-proxy/","link":"","permalink":"http://onlyH.github.io/2017/05/01/es6-proxy/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// 代理 proxy 连接用户和最真实的层// reflect反射 ==&gt; object&#123; let obj = &#123; name: 'lele', time: '2012-12-12', _r: 123 &#125; let monitor = new Proxy(obj, &#123; // 拦截对象属性的读取 get(target, key) &#123; return target[key].replace('2012', '2018') &#125;, // 拦截对象设置属性 set(target, key, value) &#123; if (key == 'name') &#123; return target[key] = value &#125; else &#123; return target[key] &#125; &#125;, // 拦截key in object操作 has(target, key) &#123; if (key == 'name') &#123; return target[key] &#125; else &#123; return false &#125; &#125;, // 拦截delete deleteProperty(target, key) &#123; if (key.indexOf('_') &gt; -1) &#123; delete target[key] return true &#125; else &#123; return target[key] &#125; &#125;, // 拦截Object.keys,Object.getOwnProperty,Object,getOwnPropertyNames ownKeys(target) &#123; return Object.keys(target).filter(item =&gt; item != 'time') &#125; &#125;) console.log('get', monitor.time) //2018-12-12 monitor.name = 'dd' console.log('set', monitor) //Proxy &#123;name: \"dd\", time: \"2012-12-12\", _r: 123&#125; console.log('has', 'name' in monitor, 'time' in monitor) //has true false delete monitor.name; delete monitor._r console.log('delete', monitor) //delete Proxy &#123;name: \"dd\", time: \"2012-12-12\"&#125; console.log('ownkey', Object.keys(monitor)) //ownkey (2) [\"name\", \"_r\"]&#125;&#123; let obj = &#123; name: 'lele', time: '2012-12-12', _r: 'dog' &#125; let monitor = Reflect.get(obj, 'time') console.log(monitor) //2012-12-12 let setName = Reflect.set(obj, 'name', 'yoyo') console.log(\"setName\", setName) //true Reflect.set(obj, 'name', 'pp') console.log(obj) //&#123;name: \"pp\", time: \"2012-12-12\", _r: \"dog\"&#125; console.log('has', Reflect.has(obj, 'name')) //true&#125;//对数据进行校验 ====&gt;使用场景// 建立函数，提供代理&#123; function validator(target, validator) &#123; return new Proxy(target, &#123; _validator : validator, set(target, key, value, proxy) &#123; if (target.hasOwnProperty(key)) &#123; //判断是否满足条件 let va = this._validator[key]; if (!!va(value)) &#123; return Reflect.set(target, key, value, proxy) &#125; else &#123; throw Error(`不可以设置`) &#125; &#125; else &#123; throw Error(`$&#123;key&#125; 报错了`) &#125; &#125; &#125;) &#125; // 校验条件 const personValidator = &#123; name(val) &#123; return typeof val === 'string' &#125;, age(val) &#123; return typeof val === 'number' &amp;&amp; val &gt; 18 &#125; &#125; class Person &#123; constructor(name, age) &#123; this.name = name this.age = age return validator(this, personValidator) &#125; &#125; const people = new Person('lili', 28) console.log(people) //Proxy &#123;name: \"lili\", age: 28&#125; /* people.name = 'rr' console.log(people) people.age = 12 console.log(people) */ const people1 = new Person('yoy',12) console.log(people1)&#125;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"上传文件报错","slug":"hexo","date":"2017-04-30T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/05/01/hexo/","link":"","permalink":"http://onlyH.github.io/2017/05/01/hexo/","excerpt":"今日上传代码，遇到一个坑，hexo h报错：12345678910111213141516171819202122232425FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 5, Column 20] expected variable end at Object._prettifyError (/Users/shuan/Desktop/blog/blog/node_modules/nunjucks/src/lib.js:36:11) at Template.render (/Users/shuan/Desktop/blog/blog/node_modules/nunjucks/src/environment.js:524:21) at Environment.renderString (/Users/shuan/Desktop/blog/blog/node_modules/nunjucks/src/environment.js:362:17) at Promise (/Users/shuan/Desktop/blog/blog/node_modules/hexo/lib/extend/tag.js:66:9) at Promise._execute (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/debuggability.js:313:9) at Promise._resolveFromExecutor (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/promise.js:483:18) at new Promise (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/promise.js:79:10) at Tag.render (/Users/shuan/Desktop/blog/blog/node_modules/hexo/lib/extend/tag.js:64:10) at Object.tagFilter [as onRenderEnd] (/Users/shuan/Desktop/blog/blog/node_modules/hexo/lib/hexo/post.js:230:16) at Promise.then.then.result (/Users/shuan/Desktop/blog/blog/node_modules/hexo/lib/hexo/render.js:65:19) at tryCatcher (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/promise.js:512:31) at Promise._settlePromise (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/promise.js:569:18) at Promise._settlePromise0 (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/promise.js:614:10) at Promise._settlePromises (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/promise.js:694:18) at _drainQueueStep (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/async.js:138:12) at _drainQueue (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/async.js:131:9) at Async._drainQueues (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/async.js:147:5) at Immediate.Async.drainQueues [as _onImmediate] (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/async.js:17:14) at runCallback (timers.js:794:20) at tryOnImmediate (timers.js:752:5) at processImmediate [as _immediateCallback] (timers.js:729:5) 可能是标记异常，想到今天写的一篇关于vue的文档，赶紧回原文看了看。原来是文章中使用了大括号 { } 这个特殊字符,且没有转义导致编译不通过 Template render error 模板渲染错误解决方案：将 { } 的大括号通过&amp;#123;和&amp;#125; 进行转换","text":"今日上传代码，遇到一个坑，hexo h报错：12345678910111213141516171819202122232425FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 5, Column 20] expected variable end at Object._prettifyError (/Users/shuan/Desktop/blog/blog/node_modules/nunjucks/src/lib.js:36:11) at Template.render (/Users/shuan/Desktop/blog/blog/node_modules/nunjucks/src/environment.js:524:21) at Environment.renderString (/Users/shuan/Desktop/blog/blog/node_modules/nunjucks/src/environment.js:362:17) at Promise (/Users/shuan/Desktop/blog/blog/node_modules/hexo/lib/extend/tag.js:66:9) at Promise._execute (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/debuggability.js:313:9) at Promise._resolveFromExecutor (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/promise.js:483:18) at new Promise (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/promise.js:79:10) at Tag.render (/Users/shuan/Desktop/blog/blog/node_modules/hexo/lib/extend/tag.js:64:10) at Object.tagFilter [as onRenderEnd] (/Users/shuan/Desktop/blog/blog/node_modules/hexo/lib/hexo/post.js:230:16) at Promise.then.then.result (/Users/shuan/Desktop/blog/blog/node_modules/hexo/lib/hexo/render.js:65:19) at tryCatcher (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/util.js:16:23) at Promise._settlePromiseFromHandler (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/promise.js:512:31) at Promise._settlePromise (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/promise.js:569:18) at Promise._settlePromise0 (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/promise.js:614:10) at Promise._settlePromises (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/promise.js:694:18) at _drainQueueStep (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/async.js:138:12) at _drainQueue (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/async.js:131:9) at Async._drainQueues (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/async.js:147:5) at Immediate.Async.drainQueues [as _onImmediate] (/Users/shuan/Desktop/blog/blog/node_modules/bluebird/js/release/async.js:17:14) at runCallback (timers.js:794:20) at tryOnImmediate (timers.js:752:5) at processImmediate [as _immediateCallback] (timers.js:729:5) 可能是标记异常，想到今天写的一篇关于vue的文档，赶紧回原文看了看。原来是文章中使用了大括号 { } 这个特殊字符,且没有转义导致编译不通过 Template render error 模板渲染错误解决方案：将 { } 的大括号通过&amp;#123;和&amp;#125; 进行转换","categories":[{"name":"hexo","slug":"hexo","permalink":"http://onlyH.github.io/categories/hexo/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"Mac 终端中用指定文本编辑器打开选中文件","slug":"mac编辑器","date":"2017-04-30T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/05/01/mac编辑器/","link":"","permalink":"http://onlyH.github.io/2017/05/01/mac编辑器/","excerpt":"","text":"之前每次用terminal打开文件都是open . 打开父文件夹然后用编辑器打开要打开的文件，或者cat查看当前文件内容。很不舒服，于是，就开始研究命令，果不其然，真的有办法123open -t index.htmlopen -e inex.htmlopen -a WebStorm index.html -t使用默认编辑器打开 -e文本编辑器打开 -a指定应用","categories":[{"name":"tools","slug":"tools","permalink":"http://onlyH.github.io/categories/tools/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"vue-slot","slug":"slot","date":"2017-04-30T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/05/01/slot/","link":"","permalink":"http://onlyH.github.io/2017/05/01/slot/","excerpt":"","text":"1234567//goods.vue&lt;span slot=\"A\"&gt;啦啦啦&lt;/span&gt;&lt;span slot=\"B\"&gt;嘿嘿嘿&lt;/span&gt;//list.vue&lt;slot name=\"A\"&gt;&lt;/slot&gt;&lt;slot name=\"B\"&gt;&lt;/slot&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://onlyH.github.io/categories/vue/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"表单验证，滚动到错误位置","slug":"表单验证滚动","date":"2017-03-02T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/03/03/表单验证滚动/","link":"","permalink":"http://onlyH.github.io/2017/03/03/表单验证滚动/","excerpt":"","text":"今日有个需求是，表单验证的时候，不弹toast，而是滚动到错误位置，公司代码实现就不写了，记录下自己写的demo。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; div &#123; height: 1500px; &#125; button &#123; width: 100px; height: 50px; line-height: 50px; background-color: rgb(0, 195, 255); color: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;label for=\"\"&gt;请输入&lt;/label&gt; &lt;input type=\"text\" id=\"check\"&gt; &lt;p id=\"tips\" style=\"color:red;\"&gt;输入有误哟&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;button&gt;确认&lt;/button&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\"&gt;&lt;/script&gt; &lt;script&gt; //jquery $('#tips').hide() //获取某个元素距离文档区域的距离 function move(id) &#123; var currentScroll = $('#' + id).offset().top $('html,body').animate(&#123; scrollTop: currentScroll &#125;) &#125; $('button').on('click', function() &#123; if ($('#check' == undefined)) &#123; $('#tips').show() move('check') &#125; &#125;) //javascript function $(id) &#123; return document.querySelector(id) &#125; $('#tips').style.display = 'none' $('button').onclick = function() &#123; if ($('#check').innerHTML == '') &#123; $('#tips').style.display = 'block' $('html').scrollTop = $('#check').offsetTop; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"学习","slug":"学习","permalink":"http://onlyH.github.io/tags/学习/"}]},{"title":"日常js","slug":"函数作为参数","date":"2017-02-28T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/03/01/函数作为参数/","link":"","permalink":"http://onlyH.github.io/2017/03/01/函数作为参数/","excerpt":"直接将函数名作为参数，直接调用 1234567function test1(fn) &#123; fn()&#125;function test2() &#123; alert('success')&#125;test1(test2) 定义一个调用以带参数的函数为参数的函数 1234567function test1(fn) &#123; fn(mydata)&#125;function test2(x) &#123; console.log(x)&#125;test1(test2('hello world')) 作为参数的函数不再单独定义 123456function test1(fn) &#123; fn('hello')&#125;test1(data =&gt;&#123; alert(data)&#125;) 属性删除123456789101112131415161718192021222324252627//delete只能删除属性，不可以删除一个变量,在函数内也不可以，隐式的创建一个变量可以删除var obj = &#123;x:1,y:2&#125;delete obj.x; //trueobj.x;//undefinedvar a = 1;delete a; //falsea; //1(function() &#123; var localVal = 1; return delete localVal;&#125;)()//falsefunction fd() &#123; delete fd; //false&#125;(function() &#123; function fd() &#123; return delete fd; &#125;&#125;()) //falseohNo = 1;window.ohNo; //1delete ohNo; //true","text":"直接将函数名作为参数，直接调用 1234567function test1(fn) &#123; fn()&#125;function test2() &#123; alert('success')&#125;test1(test2) 定义一个调用以带参数的函数为参数的函数 1234567function test1(fn) &#123; fn(mydata)&#125;function test2(x) &#123; console.log(x)&#125;test1(test2('hello world')) 作为参数的函数不再单独定义 123456function test1(fn) &#123; fn('hello')&#125;test1(data =&gt;&#123; alert(data)&#125;) 属性删除123456789101112131415161718192021222324252627//delete只能删除属性，不可以删除一个变量,在函数内也不可以，隐式的创建一个变量可以删除var obj = &#123;x:1,y:2&#125;delete obj.x; //trueobj.x;//undefinedvar a = 1;delete a; //falsea; //1(function() &#123; var localVal = 1; return delete localVal;&#125;)()//falsefunction fd() &#123; delete fd; //false&#125;(function() &#123; function fd() &#123; return delete fd; &#125;&#125;()) //falseohNo = 1;window.ohNo; //1delete ohNo; //true 属性检测1234567891011121314151617181920212223var cat = new Object;cat.legs = 4;cat.name = 'lele';'legs' in cat //true'abc' in cat //false'toString' in cat //truecat.hasOwnProperty('legs')//truecat.hasOwnProperty('toString') //false//是否可枚举cat.propertyIsEnumerable('legs');//truecat.propertyIsEnumerable('toString');//false//在枚举是false的方法,Object.defineProperty默认的属性都是false Object.defineProperty(cat,'price',&#123; enumerable:false, value:1000&#125;)cat.propertyIsEnumerable('price') //falsecat.hasOwnProperty('price') //true 12345678910if(cat &amp;&amp; cat.legs) &#123; cat.legs *=2&#125; if(cat.legs != undefined) &#123; // !=undefined or !=null&#125; if(cat.legs !== undefined) &#123; // only id cat.legs is not undefined&#125; 属性枚举123456789101112131415161718192021 var o = &#123; x:1, y:2, z:3&#125;'toString' in o;//trueo.propertyIsEnumerable('toString') //falsefor(var key in o) &#123; console.log(key) //x,y,z&#125;var obj = Object(o)obj.a = 4;for(var i in obj) &#123; console.log(i) //a,x,y,z&#125;for(var o in obj) &#123; if(obj.hasOwnProperty(key)) &#123; console.log)(a) //a &#125;&#125; 属性getter/setter方法123456789101112var person = &#123; name:'lele', get age() &#123; return new Date().getFullYear() -2014 &#125;, set age(val) &#123; console.log('no set' +val) &#125;&#125;console.log(person.age) //4person.age = 20 //no set20console.log(person.age) //4","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"感悟","slug":"感悟","permalink":"http://onlyH.github.io/tags/感悟/"}]},{"title":"变量","slug":"变量","date":"2016-12-31T16:00:00.000Z","updated":"2019-07-28T07:56:28.000Z","comments":true,"path":"2017/01/01/变量/","link":"","permalink":"http://onlyH.github.io/2017/01/01/变量/","excerpt":"全局变量 全局变量可以减少变量的个数，减少由于实际参数和形式参数的数据传递带来的时间消耗 全局变量保存在静态存储区，程序开始运行时为其分配内存，程序结束的时候释放该内存，局部变量的动态分配，动态释放相比，生存期比较长，因此过多的全局变量会占用较多的内存单元。 全局变量破坏了函数的封装性能。函数象一个黑匣子，一般是通过函数参数 和返回值进行输入输出，函数内部实现相对独立。但函数中如果使用了全局变量， 那么函数体内的语句就可以绕过函数参数和返回值进行存取，这种情况破坏了函 数的独立性，使函数对全局变量产生依赖。同时，也降低了该函数的可移植性。 全局变量使函数的代码可读性降低。由于多个函数都可能使用全局变量，函 数执行时全局变量的值可能随时发生变化，对于程序的查错和调试都非常不利。 因此，如果不是万不得已，最好不要使用全局变量。 局部变量","text":"全局变量 全局变量可以减少变量的个数，减少由于实际参数和形式参数的数据传递带来的时间消耗 全局变量保存在静态存储区，程序开始运行时为其分配内存，程序结束的时候释放该内存，局部变量的动态分配，动态释放相比，生存期比较长，因此过多的全局变量会占用较多的内存单元。 全局变量破坏了函数的封装性能。函数象一个黑匣子，一般是通过函数参数 和返回值进行输入输出，函数内部实现相对独立。但函数中如果使用了全局变量， 那么函数体内的语句就可以绕过函数参数和返回值进行存取，这种情况破坏了函 数的独立性，使函数对全局变量产生依赖。同时，也降低了该函数的可移植性。 全局变量使函数的代码可读性降低。由于多个函数都可能使用全局变量，函 数执行时全局变量的值可能随时发生变化，对于程序的查错和调试都非常不利。 因此，如果不是万不得已，最好不要使用全局变量。 局部变量 当局部变量与全局变量同名的时候，全局变量会被局部变量覆盖。也就是说 函数在使用该变量的时候会以局部变量覆盖全局变量，也就是只有局部变量会起 效果。在此定义域中赋值等操作时都不会使用到全局变量。 在 main 函数或其他函数里定义了局部变量，同时同名的全局变量同时也存 在，当调用一个使用了该变量的函数(该变量在此函数中无定义)时，函数会使 用全局变量。而不是 main 或其他函数中定义的同名变量 var 没有块级作用域 可以重复使用 无法限制修改","categories":[{"name":"js","slug":"js","permalink":"http://onlyH.github.io/categories/js/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://onlyH.github.io/tags/编程/"},{"name":"感悟","slug":"感悟","permalink":"http://onlyH.github.io/tags/感悟/"}]}]}